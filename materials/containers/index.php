<?php
include ("index.config.php");
include ($r_base."assets/php_modules/addons.php");

?>
<!DOCTYPE html>
<html lang="ru">
<head>
<?php include ($r_base."assets/php_modules/head.tpt.php"); ?>
</head>
<body>
<div class='container-fluid'>
<?php include ($r_base."assets/php_modules/header.tpt.php"); ?>  
<div class="row">
<?php include ($r_base."assets/php_modules/aside.tpt.php"); ?>
<main class="col-md markdown-body">
<p class="text-justify">&#8226; АТД - тип данных, определяемый только через операции, которые могут выполняться над соответствующими объектами безотносительно к способу представления этих объектов. </p>
<p class="text-justify">&#8226; АТД включает в себя абстракцию как через параметризацию, так и через спецификацию. </p>
<h2 id="1">1. Абстракция через параметризацию</h2>
<p class="text-justify">&#8226; Абстракция через параметризацию может быть осуществлена так же, как и для процедур (функций); использованием параметров там, где это имеет смысл. </p>
<h2 id="2">2. Абстракция через спецификацию </h2>
<p class="text-justify">&#8226; Абстракция через спецификацию достигается за счет того, что операции представляются как часть типа. </p>
<p class="text-justify">&#8226; Для реализации АТД необходимо, во-первых, выбрать представление памяти для объектов и, во-вторых, реализовать операции в терминах выбранного представления. </p>
<p class="text-justify">&#8226; Примером абстрактного типа данных является класс в языке С++. В реальных задачах требуется обрабатывать группы данных большого объема, поэтому в любом языке программирования существуют средства, позволяющие объединять данные в группы. В первую очередь это массивы. В С++ массивы – это очень простые конструкции. В ООП этого недостаточно для работы с группами однородных данных. Поэтому была выработана более общая концепция объединения однородных данных в группу – контейнер. [1]</p>
<h2 id="3">3. Контейнеры</h2>
<p class="text-justify">&#8226; Контейнер – набор однотипных элементов. Встроенные массивы в С++ - частный случай контейнера. </p>
<p class="text-justify">&#8226; Контейнер – это объект. Имя контейнера – это имя переменной. Контейнер, так же как и другие объекты, обладает временем жизни. Время жизни контейнера в общем случае не зависит от времени жизни его элементов. Элементами контейнера могут любые объекты, в том числе, и другие контейнеры. </p>
<p class="text-justify">&#8226; Контейнеры могут быть фиксированного и переменного размера. В контейнере фиксированного размера число элементов постоянное, оно обычно задается при создании контейнера. Примером такого контейнера является массив. Для контейнера переменного размера количество элементов при объявлении обычно не задается. Элементы в таком контейнере добавляются и удаляются во время работы программы. Примером является список. Если элементы контейнера не упорядочены, то добавление и удаление элементов обычно выполняется в начале и в конце контейнера. Способ вставки и удаления определяет вид контейнера. Если вставка и удаление осуществляется на одном конце, то такой контейнер называется стеком (<code class="highlight">Last In First Out</code> – последним пришел, первым ушел). Если элементы добавляются на одном конце контейнера, а удаляются на другом, то такой контейнер называется очередью (<code class="highlight">First In First Out</code> – первым пришел, последним ушел). Можно выполнять вставку и удаление на обоих концах контейнера, тогда такой контейнер будет называться двусторонней очередью (<code class="highlight">deque</code> – <code class="highlight">double ended queue</code>).</p>
<p class="text-justify">&#8226; Если контейнер каким-то образом упорядочен, то операция вставки работает в соответствии с порядком элементов в контейнере. Операция удаления может выполняться по-разному: в начале, в конце или удаление заданного элемента. [2]</p>
<h2 id="4">4. Операции контейнера</h2>
<p class="text-justify">&#8226; Среди всех операций контейнера можно выделить несколько типовых групп:</p>
<ol>
    <li>Операции доступа к элементам, которые обеспечивают и операцию замены значений элементов; </li>
    <li>Операции добавления и удаления элементов или групп элементов; </li>
    <li>Операции поиска элементов и групп элементов; </li>
    <li>Операции объединения контейнеров; </li>
    <li>Специальные операции, которые зависят от вида контейнера. [3]</li>
</ol>
<p class="text-justify">&#8226; Примером контейнера может быть пользовательский тип, реализующий динамический массив:</p>
<pre class="highlight"><code data-language="c">class Container // Определяем класс-контейнер
{
private:
	int* arr;
	int size;

public:
	// Конструктор с выделением памяти под массив
	Container(int _size) : size(_size)
	{
		arr = new int[_size];
	}

	// Деструктор, чистящий дин. память
	~Container()
	{
		delete[] arr;
	}

	// Перегрузка операции обращения по индексу
	int& operator [] (int index)
	{
		return arr[index];
	}
};</code></pre>
<p class="text-justify">&#8226; В данном примере показана, ранее не изученная, перегрузка обращения по индексу [] – она принимает целочисленный аргумент (индекс) и возвращает ссылку на компонент в объекте-контейнере.</p>
<p class="text-justify">&#8226; Однако использование таких контейнеров бывает редко. Как правило, реализуют динамические структуры данных такие, как списки, стеки очереди. [4]</p>
<p class="text-justify">&#8226; В качестве примера использования ДСД – как контейнера, стоит рассмотреть самый простой его пример – односвязный список с единственным методом (добавление в начало) для упрощения.</p>
<pre class="highlight"><code data-language="c">struct Node
{
	int data;
	Node* pNext;
};

class List // Определяем односвязный список
{
private:
	Node* pFirst;

public:
	List() : pFirst(NULL) {}

	// метод добавления записи
	List& push_front(int data)
	{
		Node* temp = new Node;
		temp->data = data;
		temp->pNext = pFirst;
		pFirst = temp;
		return *this;
	}

	// Перегрузка операции обращения по индексу
	int& operator [] (int index)
	{
		Node* temp = pFirst;
		for (int i = 0; i < index; i++)
			temp = temp->pNext;
		return temp->data;
	}
};</code></pre>
<p class="text-justify">&#8226; Такой код можно усовершенствовать методами, соответствующими ДСД Односвязный список. И кроме того, находят частое использование так называемые классы-итераторы.</p>
<p class="text-justify">&#8226; Итератор – внутренний класс для класса-контейнера, объявленный в <code class="highlight">public</code>. Используется для перемещения по компонентам контейнера. [5]</p>
<p class="text-justify">&#8226; Теперь предстоит добавить в существующий класс-контейнер класс-итератор. Для удобства представления кода принято разделять инициализацию в файл заголовка (<code class="highlight">*.h</code>) и определение в файл исходного текста (<code class="highlight">*.cpp</code>). Так решено поступить и в данном случае.</p>
<p class="text-justify">&#8226; Файл заголовка:</p>
<pre class="highlight"><code data-language="c">struct Node
{
	int data;
	Node* pNext;
};

class List // Определяем односвязный список
{
private:
	Node* pFirst;

public:
	List() : pFirst(NULL) {}

	// метод добавления записи
	List& push_front(int);

	// Перегрузка операции обращения по индексу
	int& operator [] (int);

	// Объявление внутреннего класса-итератора
	class Iterator
	{
	protected:
		Node* iter;

	public:
		Iterator(Node* node) : iter(node) {}

		// перегрузка инкрементов
		Iterator& operator ++ ();
		Iterator operator ++ (int);

		// перегрузка сравнения итераторов
		bool operator != (Iterator right);

		// получение ссылки на запись
		int& get();
	};

	// Получение итераторов
	Iterator start();
	Iterator end();
};</code></pre>
<p class="text-justify">&#8226; Файл исходного текста:</p>
<pre class="highlight"><code data-language="c">List& List::push_front(int data)
{
	Node* temp = new Node;
	temp->data = data;
	temp->pNext = pFirst;
	pFirst = temp;
	return *this;
}

int& List::operator [] (int index)
{
	Node* temp = pFirst;
	for (int i = 0; i < index; i++)
		temp = temp->pNext;
	return temp->data;
}

List::Iterator& List::Iterator::operator ++ ()
{
	iter = iter->pNext;
	return *this;
}

List::Iterator List::Iterator::operator ++ (int)
{
	List::Iterator temp(iter);
	iter = iter->pNext;
	return temp;
}

int& List::Iterator::get()
{
	return iter->data;
}

bool List::Iterator::operator != (Iterator right)
{
	return bool(iter != right.iter);
}

List::Iterator List::start()
{
	return List::Iterator(pFirst);
}

List::Iterator List::end()
{
	return List::Iterator(NULL);
}</code></pre>
<p class="text-justify">&#8226; В инициализацию класса-контейнера были добавлены класс-итератор и методы, позволяющие получить начальный и конечный итераторы. В классе-итераторе реализованы операции инкремента, для перехода к последующему итератору, операция сравнения итераторов и получение ссылки на компонент в объекте контейнере.</p>
<p class="text-justify">&#8226; Все это позволяет выполнить следующий код:</p>
<pre class="highlight"><code data-language="c">int main()
{
	List list;
	list.push_front(13).push_front(29).push_front(16);

	for (List::Iterator iter = list.start(); iter != list.end(); iter++)
		cout << iter.get() << " ";

	cout << endl;

	system("pause");
	return 0;
}</code></pre>
<p class="text-justify">&#8226; Результатом запуска программы будет:</p>
<div class="gallery">
	<a href="<?php echo $folder_name ?>img/1.png">
	<img src="<?php echo $folder_name ?>img/1.png" alt="Рисунок 1">
	</a>
</div>

<p class="text-center">Рисунок 1 - Вывод программы</p>
<p class="text-justify">&#8226; Таким образом, были рассмотрены: перегрузка операции [], создание классов-контейнеров на примере односвязного списка, классы-итераторы и работа с ними.</p>
<h2 id="5">5. Список использованных источников</h2>
<ol>
    <li>Браунси, Кен. Структура данных и реализация в С++, 2016. –122с.</li>
    <li>Вирт, Никалаус. Алгоритмы и структуры данных, 2017. –114с.</li>
    <li>Саттер, Герб. Решение сложных задач на C++, 2017. – 400 c.</li>
    <li>Мэйерс, Скотт. Эффективное использование C++. 55 верных способов улучшить структуру и код ваших программ, 2017. – 300 c. </li>
    <li>Стивенс Род. Алгоритмы теория и практическое применение, 2016. –163с.</li>
</ol>
</main><!--end main-->
</div><!--end .row-->
<?php include ($r_base."assets/php_modules/footer.tpt.php"); ?>  
</div><!--end .container-fluid-->
<?php include ($r_base."assets/php_modules/scripts.tpt.php"); ?>
</body>
</html>