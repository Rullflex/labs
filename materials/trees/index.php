<?php
include ("index.config.php");
include ($r_base."assets/php_modules/addons.php");

?>
<!DOCTYPE html>
<html lang="ru">
<head>
<?php include ($r_base."assets/php_modules/head.tpt.php"); ?>
</head>
<body data-spy="scroll" data-target="#aside-desktop__navbar" data-offset="0">
<div class='container-fluid'>
<?php include ($r_base."assets/php_modules/header.tpt.php"); ?>  
<div class="row">
<?php include ($r_base."assets/php_modules/aside.tpt.php"); ?>
<main class="col-md markdown-body">


<h2>Понятие дерева</h2>		
<p><em>Дерево</em> &ndash; это множество данных, представляющее собой древовидную структуру в виде набора связанных узлов.</p>
<p><em>Узел</em> &ndash; это единица хранения данных в дереве, имеющая также указатели на связанные с ней узлы.</p>
<p><em>Дочерний узел</em> <em>(потомок)</em> &ndash; это узел, который находится непосредственно под другим узлом и связан с ним с помощью указателя.</p>
<p><em>Родительский узел</em> &ndash; это узел, который находится непосредственно над другим узлом и связан с ним с помощью указателя.</p>
<p><em>Корневой узел</em> &ndash; это узел, не имеющий родительских узлов.</p>
<p><em>Лист</em> &ndash; это узел, не имеющий дочерних узлов.</p>
<h2>1. Бинарное дерево</h2> 
<p>Одной из разновидностей деревьев являются бинарные деревья. Бинарное дерево связывает до двух других дочерних узлов, которые можно визуализировать пространственно ниже родительского узла, один из которых расположен слева, а другой справа. Именно связь между дочерними и родительским узлами делает бинарное дерево такой эффективной структурой данных.</p>
<div class="gallery">
	<a href="<?php echo $folder_name ?>img/1.png">
	    <img src="<?php echo $folder_name ?>img/1.png" alt="Рисунок 1">
	</a>
</div>
<p class="text-center lead my-2">Рисунок 1 &ndash; Бинарное дерево</p>
<ol>
<li>Корневой узел &ndash; элемент А на рисунке 1.</li>
<li>Дочерние узлы для элемента А &ndash; узлы В и С.</li>
<li>Родительский узел для элемента G &ndash; узел D.</li>
<li>Листья &ndash; элементы G, H и I.</li>
</ol>
<h3>1.1 Зачем нужны бинарные деревья?</h3> 
<ol>
<li>Если необходимо расположить информацию, связанную между собой некой иерархией. Примером является файловая система компьютера.</li>
<li>Если необходимо хранить данные, составленные в виде определённой структуры. Тогда хранение в виде бинарного дерева позволяет уменьшить скорость поиска данных и доступа к хранимой информации.</li>
<li>Если необходима высокая скорость добавления или удаления данных.</li>
<li>Если заранее неизвестен хранимый объем данных. Бинарные деревья, также, как и связанные списки, не имеют ограничения на количество узлов, поскольку узлы связаны указателями.</li>
</ol>
<h3>1.2 Реализация бинарного дерева в </strong><strong>C</strong><strong>++</strong></h3> 
<p>Во-первых, необходимо создать структуру, которая будет описывать узел бинарного дерева.</p>

<pre class="highlight"><code data-language="c">
struct node
{
    int key_value; //ключ – значение узла, типа int
    node* left;    //указатель на левого потомка
    node* right;   //указатель на правого потомка
};
</code></pre>
<p>Далее, создается класс бинарного дерева, для его инкапсуляции в одну область памяти, а также для многоразового доступа к нему.</p>
<pre class="highlight"><code data-language="c">
class btree
{
public:
    btree();                            	//Конструктор
    ~btree();                           	//Деструктор

    void insert(int key);               	//Функция вставки
    node* search(int key);			//Функция поиска
    void destroy_tree();               	//Функция удаления дерева

private:
void destroy_tree(node* leaf);		//Рекурсивная функция удаления 								//дерева
void insert(int key, node* leaf);	//Рекурсивная функция //добавления узла в дерево
node* search(int key, node* leaf);	//Рекурсивная функция поиска //узла дерева с заданным //ключевым значением

    node* root;					//Атрибут класса(Корневой узел)
};

</code></pre>
<p>Класс содержит функции для вставки данных в дерево и для поиска данных. Также в класс включается функция для удаления дерева с целью очищения памяти после завершения программы.</p>
<p>Функции вставки и поиска данных, которые являются открытыми членами класса, предназначены для того, чтобы пользователь класса мог использовать его, не имея дело с базовой структурой класса.</p>
<p>Функции вставки и поиска данных, которые располагаются в поле private: имеют два параметра: значение ключа узла и указатель на одного из потомков. Функции вызываются рекурсивно, что позволяет двигаться от узла к узлу по дереву.</p>
<p>Программный код функций класса выглядит следующим образом:</p>
<p>Конструктор</p>
<pre class="highlight"><code data-language="c">
btree::btree()
{
 		      root = NULL;	       // Корневой узел без дочерних элементов
}
</code></pre>
<p>Деструктор</p>
<pre class="highlight"><code data-language="c">
btree::~btree()
{
destroy_tree(); 	//При удалении дерева, необходимо удалить все //элементы
}
</code></pre>
<p>Функция <em>destroy</em><em>_</em><em>tree</em><em>()</em> вызывает рекурсивную функцию <em>destroy</em><em>_</em><em>tree</em><em>(</em><em>node</em><em>* </em><em>leaf</em><em>)</em>, которая удалит все узлы дерева.</p>
<pre class="highlight"><code data-language="c">
void btree::destroy_tree(node *leaf)
{
      if(leaf!=NULL)				//Если узел дерева существует
      {						//Функция вызовет сама себя
          destroy_tree(leaf->left);	//сначала для левого потомка,
          destroy_tree(leaf->right);  	//после для правого потомка.
          delete leaf;			//Если потомков нет, она удалит
//Узел, полученный в качестве параметра //функции
      }
}
</code></pre>

<div class="gallery">
	<a href="<?php echo $folder_name ?>img/2.png">
	    <img src="<?php echo $folder_name ?>img/2.png" alt="Рисунок 2">
	</a>
</div>
<p class="text-center lead my-2">Рисунок 2 &ndash; Демонстрация работы рекурсивной функции destroy_tree</p>

<p>Функция добавления элемента с заданным ключевым значением:<br> 
<pre class="highlight"><code data-language="c">
void btree::insert(int key)     //Функция, доступная для элементов, которые не   являются членами класса
{					//Сначала проверит корневой элемент
  if(root!=NULL)			//Если он не инициализирован,
    insert(key, root);		//то вызовется рекурсивная функция
					//для добавления элемента.
 
  else				      //Иначе Функция поместит новое значение:
  {					
    root=new node;		      //инициализируется корневой элемент 
    root->key_value=key;	      //поместится ключевое значение
					//в соответствующую ячейку структуры. 
    root->left=NULL;		//Инициализируется указатель на левый
    root->right=NULL;		//и правый элемент как NULL
  }
}

//Рекурсивная функция для вставки элемента.
void btree::insert(int key, node* leaf)	//(Новое ключевое значение, указатель на //текущий узел)	
{							
if (key < leaf->key_value)  	//Если новое ключевое значение меньше чем //ключевое значение в узле
    {
        if (leaf->left != NULL)		//И если левый указатель узла инициализирован
            insert(key, leaf->left);		//Функция вызывает саму себя, для левого //узла потомка
else		//Иначе (если левый потомок не //инициализирован)
        {
            leaf->left = new node;		//Функция создаст и поместит новый элемент на //место левого потомка.
            leaf->left->key_value = key;	//Внесёт новое ключевое значение в элемент.
            leaf->left->left = NULL;    	//Установит левый дочерний указатель 
            leaf->left->right = NULL;   	//и правый дочерний указатель в NULL.
        }
    }
    else if (key >= leaf->key_value)		//Иначе Если новое ключевое значение не //меньше ключевого значения в узле 
    {
        if (leaf->right != NULL)		//И если правый указатель инициализирован,
            insert(key, leaf->right);		//То функция вызывает саму себя, для правого //потомка
else		//Иначе(если правый потомок не //инициализирован)
        {
            leaf->right = new node;		//Функция создаст и поместит новый элемент на //место правого потомка.
            leaf->right->key_value = key;	//Внесёт новое ключевое значение в элемент.
            leaf->right->left = NULL;  	//Установит левый дочерний указатель
            leaf->right->right = NULL;      //и правый дочерний указатель в NULL.
        }
    }
}
</code></pre>
<p>Так, благодаря проверке, на инициализацию указателей, функция всегда будет останавливать рекурсию, если дойдёт до нижнего элемента дерева.</p>
<p>Функция поиска элемента с заданным ключевым значением:</p>
<pre class="highlight"><code data-language="c">
node* btree::search(int key, node* leaf)	//(Ключевое значение, //указатель ну узел)
{
if (leaf != NULL)	//Если узел //инициализирован
    {
        if (key == leaf->key_value)	//И ключевое значение //узла совпадает с //искомым ключевым //значением.
return leaf;	//Возвращается указатель на //найденный элемент.
if (key < leaf->key_value)	//Иначе, если 
//искомое ключевое //значение меньше //ключевого значения узла
return search(key, leaf->left);	//Вызывается эта же функция //для левого потомка.
        else							//Иначе
            return search(key, leaf->right);	//Вызывается эта же функция //для правого потомка.
    }
    else return NULL;					//Иначе возвращается NULL.
}
</code></pre>
<p>Функция поиска узла, показанная выше, рекурсивно перемещается вниз по дереву, пока не достигнет узла с заданным значением ключа.</p>
<p>Если функция доходит до элемента со значением NULL, значит узла с заданным ключевым значением в дереве не существует.</p>
<br>

<h3>1.3 Обход бинарного дерева</h3> 
<p>Обход дерева &ndash; это посещение вех узлов дерева в определенном порядке, причем каждый узел посещается только один раз.</p>
<p>Существует несколько способов обхода всех узлов дерева:</p>
<ol>
<li>прямой;</li>
<li>симметричный;</li>
<li>обратный.</li>
</ol>

<!-- /////////////////////////////////////////////RISYNOK  3//////////////////////////////////////// -->
<br>
<div class="gallery">
	<a href="<?php echo $folder_name ?>img/3.png">
	    <img src="<?php echo $folder_name ?>img/3.png" alt="Рисунок 3">
	</a>
    </div>
    <br>
<p class="text-center">Рисунок 3 &ndash; Три способа обхода дерева</p>
<br>

<!-- ///////////////////////////////////////////////////////////////////////////////////// -->
<p>Существует множество задач, которые выполняются на структурах данных, представленных в виде бинарного дерева. Одна из самых распространенных &ndash; выполнение заданной операции с каждым элементом дерева. Чтобы отредактировать какие-либо элементы дерева, нужно совершить его обход.</p>
<p><strong>Прямой обход</strong> <strong>&ndash; сверху вниз</strong></p>
<p>Принцип действия прямого обхода дерева подробно рассматривается на основе рисунка 4.</p>

<!-- /////////////////////////////////////////////RISYNOK  4//////////////////////////////////////// -->
<br>
<div class="gallery">
	<a href="<?php echo $folder_name ?>img/4.png">
	    <img src="<?php echo $folder_name ?>img/4.png" alt="Рисунок 4">
	</a>
    </div>
    <br>
<p class="text-center">Рисунок 4 &ndash; Прямой обход</p>
<br>

<!-- ///////////////////////////////////////////////////////////////////////////////////// -->
<ol>
<li>Обход начинается с корня дерева &ndash; узел А;</li>
<li>Далее выполняется переход вниз, сначала к левому поддереву;</li>
<li>Выполняется переход к левому потомку узла А &ndash; узел B;</li>
<li>Выполняется переход к левому потомку узла В &ndash; узел D;</li>
<li>Узел D является листом, то есть ниже двигаться нет возможности;</li>
<li>Выполняется переход к правому потомку узла В &ndash; узел E;</li>
<li>Левое поддерево узла А полностью пройдено, начинается обход правого поддерева;</li>
<li>Выполняется переход к правому потомку узла А &ndash; узел С;</li>
<li>Выполняется переход к правому потомку узла С &ndash; узел F, достигнут последний узел дерева, обход завершен.</li>
</ol>
<p><strong>Симметричный обход</strong> &ndash; <strong>слева направо</strong></p>
<p>Принцип действия симметричного обхода дерева подробно рассматривается на основе рисунка 5.</p>

<!-- /////////////////////////////////////////////RISYNOK  5//////////////////////////////////////// -->
<br>
<div class="gallery">
	<a href="<?php echo $folder_name ?>img/5.png">
	    <img src="<?php echo $folder_name ?>img/5.png" alt="Рисунок 5">
	</a></div><br>
<p class="text-center">Рисунок 5 &ndash; Симметричный обход</p>
<br>

<!-- ///////////////////////////////////////////////////////////////////////////////////// -->
<ol>
<li>Обход начинается с самого нижнего левого листа &ndash; узел D;</li>
<li>Выполняется переход к родителю листа D &ndash; узел B;</li>
<li>Выполняется переход к правому потомку узла В &ndash; узел Е;</li>
<li>Узел В и все его потомки пройдены, поэтому необходимо двигаться вверх;</li>
<li>Выполняется переход к корню дерева &ndash; узел А;</li>
<li>Выполняется переход к правому потомку узла А &ndash; узел С;</li>
<li>Выполняется переход к правому потомку узла С &ndash; узел F, достигнут последний узел дерева, обход завершен.</li>
</ol>
<p><strong>Обратный</strong> <strong>обход</strong> &ndash; <strong>снизу-вверх</strong></p>
<p>Принцип действия обратного обхода дерева подробно рассматривается на основе рисунка 6.</p>

<!-- /////////////////////////////////////////////RISYNOK  6//////////////////////////////////////// -->
<br>
<div class="gallery">
	<a href="<?php echo $folder_name ?>img/6.png">
	    <img src="<?php echo $folder_name ?>img/6.png" alt="Рисунок 6">
	</a></div><br>
<p class="text-center">Рисунок 6 &ndash; Обратный обход</p>
<br>

<!-- ///////////////////////////////////////////////////////////////////////////////////// -->
<ol>
<li>Обход начинается с самого нижнего левого листа &ndash; узел D;</li>
<li>Выполняется переход к узлу Е;</li>
<li>Выполняется переход к родителю узлов D и E &ndash; узел B;</li>
<li>Левое поддерево полностью пройдено. Дальнейший обход через корень дерева игнорируется, выполняется переход к узлу F;</li>
<li>Выполняется переход к родителю узла F &ndash; узел С;</li>
<li>Выполняется переход к родителю узла С &ndash; узел А;</li>
<li>Узел А является корнем дерева, обход завершен.</li>
</ol>

<h2>2. Бинарные деревья поиска</h2> 
<p>Бинарные деревья поиска используются непосредственно для поиска элемента по заданному значению ключу. Данные в таких деревьях хранятся в отсортированном виде, что делает процедуру поиска элементов очень удобной.</p>
<h3>2.1 Понятие бинарного дерева поиска</h3> 
<p><em>Бинарное дерево поиска</em> &mdash; это бинарное дерево, обладающее дополнительными свойствами: значение левого потомка всегда меньше значения родителя, а значение правого потомка всегда больше значения родителя для каждого узла дерева.</p>
<p>Пример бинарного дерева поиска представлен на рисунке 7.</p>
<!-- /////////////////////////////////////////////RISYNOK  7//////////////////////////////////////// -->
<br>
<div class="gallery">
	<a href="<?php echo $folder_name ?>img/7.png">
	    <img src="<?php echo $folder_name ?>img/7.png" alt="Рисунок 7">
	</a></div><br>
<p class="text-center">Рисунок 7 &ndash; Бинарное дерево поиска</p>
<br>

<!-- ///////////////////////////////////////////////////////////////////////////////////// -->
<h3>2.2 Реализация бинарного дерева поиска в С++</h3> 
<p>Ниже представлен программный код класса <em>SearchTree</em>, описывающий основные методы для работы с бинарным деревом поиска. Можно не рассматривать те функции класса <em>SearchTree</em>, которые по принципу работы повторяют или значительно похожи на ранее разобранные функции класса <em>btree</em>.</p>
<pre class="highlight"><code data-language="c">
template &#60;class T>
class SearchTree
{
public:
	T data;                                   //ключ типа Т
	SearchTree* left;                         //указатель на левого потомка
	SearchTree* right;                        //указатель на правого потомка
	SearchTree* parent;                       //указатель на родителя
	SearchTree(T);                            //конструктор
	~SearchTree();                            //деструктор
	void deleteSearchTree() { delete this; }  //удалить дерево
	void printSearchTree(int);                //горизонтальная печать дерева
	void inOrder(SearchTree&#60;T>*);             //симметричный обход дерева
	void setData(T dt) { data = dt; }         //установить данные для узла
	SearchTree&#60;T>* next();                    //найти следующий элемент
	SearchTree&#60;T>* prev();                    //найти предыдущий элемент
	void insertNode(T);                       //добавить узел
	void deleteNode(T);                       //удалить узел
	SearchTree&#60;T>* findElement(T);            //найти элемент
	SearchTree&#60;T>* findMax();                 //найти максимальный элемент
	SearchTree&#60;T>* findMin();                 //найти минимальный элемент
};
</code></pre>
<p>Для простоты реализации некоторых функций, необходимо хранить указатель на родителя узла - SearchTree* parent.</p>

<h3>2.3 Описание функций класса SearchTree</h3> 
<ol>
<li>Поиск элемента с заданным ключом</li>
</ol>
<p>Для поиска элемента в бинарном дереве поиска можно воспользоваться функцией, которая принимает в качестве параметра заданное значение ключа. Для каждого узла функция сравнивает значение его ключа со значением заданного ключа. Если значения ключей одинаковы, то функция возвращает текущий узел. В противном случае, функция вызывается рекурсивно: для левого поддерева, если заданный ключ меньше ключа узла, для правого поддерева, если заданный ключ больше ключа узла. Иллюстрация поиска элемента представлена на рисунке 8.</p>

<!-- /////////////////////////////////////////////RISYNOK  8//////////////////////////////////////// -->
<br>
<div class="gallery">
	<a href="<?php echo $folder_name ?>img/8.png">
	    <img src="<?php echo $folder_name ?>img/8.png" alt="Рисунок 8">
	</a></div><br>
<p class="text-center">Рисунок 8 &ndash; Схема поиска элемента со значением ключа равным 4</p>
<br>
<!-- ///////////////////////////////////////////////////////////////////////////////////// -->
<p>Ниже представлен программный код функции поиска элемента с заданным ключом.</p>
<pre class="highlight"><code data-language="c">
template &#60;class T>
SearchTree&#60;T>* SearchTree&#60;T>::findElement(T data)
{
    if ((this == NULL) || (data == this->data))//если ключ узла равен NULL или совпал с       
        return this;                           //заданным ключом, то функция завершается, 
                                               //возвращая заданный узел дерева
    if (data < this->data) 
        return this->left->findElement(data);  //если заданный ключ меньше текущего 
                                               //ключа, то функция вызывается рекурсивно, 
                                               //но уже для левого поддерева заданного 
    else return this->right->findElement(data);//узла, в противном случае элемент ищется
                                               //в правом поддереве заданного узла, 
}                                              //до срабатывания начального if
</code></pre>

<ol start="2">
<li>Поиск минимального и максимального элементов</li>
</ol>
<p>Чтобы найти минимальный элемент в бинарном дереве поиска, необходимо следовать указателям <em>left</em> от корня дерева, пока не встретится значение <em>NULL</em>. Если у вершины есть левое поддерево, то по свойству бинарного дерева поиска, в нем хранятся все элементы с меньшим ключом. Если его нет, значит, эта вершина и есть минимальная. Аналогично ищется и максимальный элемент, для этого нужно следовать указателям <em>right</em>. Функции поиска максимального и минимального элементов продемонстрированы в программном коде, распложенном ниже.</p>
<pre class="highlight"><code data-language="c">
template &#60;class T>
SearchTree&#60;T>* SearchTree&#60;T>::findMin()     //поиск минимального элемента
{
	if (this->left == NULL) return this; //если указатель на узел слева равен NULL, 
                                            //значит текущий элемент является минимальным
	return this->left->findMin();        //иначе рекурсивно вызывая функцию,  
	                                     //двигаемся по левым поддеревьям до тех пор, 
	                                     //пока указатель на узел слева не равен NULL 
}

template &#60;class T>
SearchTree&#60;T>* SearchTree&#60;T>::findMax()     //поиск максимального элемента
{
	if (this->right == NULL) return this;//если указатель на узел справа равен NULL, 
                                            //значит текущий элемент является максимальн.
	return this->right->findMax();       //двигаемся по правым  поддеревьям до тех 
		                              //пор, пока указатель на узел справа 
                                            //не станет равным NULL
}
</code></pre>
<ol start="3">
<li>Поиск следующего и предыдущего узлов для заданного узла</li>
</ol>
<p>Поиск следующего узла осуществляется таким образом: если у заданного узла есть правое поддерево, то следующим за ним элемент будет минимальный элемент в этом поддереве. Если у него нет правого поддерева, то нужно следовать вверх, пока не встретится узел, для которого заданный является левым дочерним узлом.</p>
<p>Поиск предыдущего элемента осуществляется таким образом: если у узла есть левое поддерево, то предыдущий ему элемент будет максимальный элемент в этом поддереве. Если у него нет левого поддерева, то нужно следовать вверх, пока не встретится узел, для которого заданный является правым дочерним узлом.</p>
<p>Поиск следующего и предыдущего элементов показан на рисунке 9.</p>
<!-- /////////////////////////////////////////////RISYNOK  9//////////////////////////////////////// -->
<br>
<div class="gallery">
	<a href="<?php echo $folder_name ?>img/9.png">
	    <img src="<?php echo $folder_name ?>img/9.png" alt="Рисунок 9">
    </a></div><br>
<p class="text-center">Рисунок 9 &ndash; Поиск следующего и предыдущего элементов для заданного узла</p>
<br>
<!-- ///////////////////////////////////////////////////////////////////////////////////// -->
<p>Следующий для 4 узла &ndash;&nbsp; 6 узел, следующий для 6 узла &ndash; 7 узел, следующий для 7 узла &ndash; NULL. Предыдущий для 4 узла &ndash; NULL, предыдущий для 6 узла &ndash; 4 узел, предыдущий для 7 узла &ndash; 6 узел.</p>
<p>Ниже представлен программный код функций поиска следующего и предыдущего элементов для заданного узла.</p>
<pre class="highlight"><code data-language="c">
template &#60;class T>
SearchTree&#60;T>* SearchTree&#60;T>::next()     //поиск следующего элемента
{
	SearchTree* tree = this;          //заданный узел запоминается во вспомогательный, 
                                         //чтобы не перемещать его при поиске  
	if (tree->right != NULL)          //если правое поддерево заданного узла сущ.,
	    return tree->right->findMin();//то ищется минимальный элемент в этом 
						//правом поддереве (он и будет следующим 
                                         //для заданного)
	SearchTree&#60;T>* t = tree->parent;  //в противном случае, нужно двигаться 
                                         //вверх до тех пор, 
                                         //пока не встретится узел, для которого заданный 
                                         //является левым дочерним узлом 
  while ((t != NULL)&&(tree == t->right))//пока узел является правым дочерним для своего 
					       //родителя и родитель существует, выполняем цикл
	{
		tree = t;                   //запоминаем текущий узел
		t = t->parent;              //переходим к его родителю
	}
	return t;
}

template &#60;class T>
SearchTree&#60;T>* SearchTree&#60;T>::prev()     //поиск предыдущего элемента
{
	SearchTree* tree = this;
	if (tree->left != NULL)
		return tree->left->findMax();
	SearchTree&#60;T>* t = tree->parent;
	while ((t != NULL) && (tree == t->left))
	{
		tree = t;
		t = t->parent;
	}
	return t;
}
</code></pre>
<ol start="4">
<li>Добавление элемента с заданным ключом в бинарное дерево поиска</li>
</ol>
<p>При вставке элемента в бинарное дерево поиска необходимо учитывать два случая:</p>
<ul>
<li>Дерево пустое;</li>
<li>Дерево непустое.</li>
</ul>
<p>Если дерево пустое, то создается новый узел, который добавляется в дерево. Если дерево не пустое, то значение ключа добавляемого элемента сравнивается со значением ключа в узле, начиная от корня. Если добавляемое значение ключа меньше значения ключа рассматриваемого узла, выполняется вышеописанная процедура сравнения для левого поддерева. Если добавляемое значение ключа больше значения ключа рассматриваемого узла, то процедура сравнения выполняется для правого поддерева. Пример добавления элемента представлен на рисунке 10.</p>
<!-- /////////////////////////////////////////////RISYNOK  10//////////////////////////////////////// -->
<br>
<div class="gallery">
	<a href="<?php echo $folder_name ?>img/10.png">
	    <img src="<?php echo $folder_name ?>img/10.png" alt="Рисунок 10">
	</a></div><br>
<p class="text-center">Рисунок 10 &ndash; Добавление элемента со значением ключа равным 8</p>
<br>

<!-- ///////////////////////////////////////////////////////////////////////////////////// -->
<p>Ниже представлен программный код функции добавления элемента с заданным ключом в бинарное дерево поиска.</p>
<pre class="highlight"><code data-language="c">
template &#60;class T>
void SearchTree&#60;T>::insertNode(T dt)
{
	SearchTree&#60;T>* tree = this;
	while (tree != NULL)               //пока узел существует выполняется цикл
	{                                  //если ключ добавляемого элемента
		if (dt >= tree->data)       //больше или равен ключу    
		{                           //текущего узла, анализируется правое поддерево
		     if (tree->right != NULL)  //если узел справа существует, происходит	 
			{                        //переход к нему и выполнение
				tree = tree->right;//цикла начинается сначала
			}
			else                   //иначе добавляем новый элемент в узел                                     
			{                      //справа, настроив все необходимые указатели
				SearchTree&#60;T>* t = new SearchTree&#60;T>(dt);//для нового элемента
				t->parent = tree;
				tree->right = t;
				break;
			}
		}
		else if (dt < tree->data)     //если ключ добавляемого элемента меньше 	                                  
		{                             //ключа текущего узла, анализируется 
                                            //левое поддерево
			if (tree->left != NULL) //если узел слева существует, происходит  
			{                      //переход к нему и выполнение цикла начинается 
				tree = tree->left;// сначала
			}
			else                                        //иначе добавляется новый                                 
			{   	                                       //элемент в узел слева,                     
				SearchTree&#60;T>* t = new SearchTree&#60;T>(dt);//настраиваются все  
				t->parent = tree;                      //необходимые указатели                         
				tree->left = t;                        //для нового элемента
				break;
			}
		}
	}
}
</code></pre>

<h3>2.4 Идеально сбалансированное деревоe</h3> 
<p>Бинарное дерево называется <em>идеально сбалансированным (ИСД)</em>, если для каждого его узла количество узлов в левом и правом поддеревьях отличается не более чем на единицу (рисунок 11). Идеально сбалансированное дерево из n узлов имеет минимальную высоту для бинарного дерева, которая вычисляется по формуле: [log<sub>2</sub>n] + 1.</p>
<!-- /////////////////////////////////////////////RISYNOK  11//////////////////////////////////////// -->
<br>
<div class="gallery">
	<a href="<?php echo $folder_name ?>img/11.png">
	    <img src="<?php echo $folder_name ?>img/11.png" alt="Рисунок 11">
	</a></div><br>
<p class="text-center">Рисунок 11 &ndash; Идеально сбалансированное дерево</p>
<br>
<!-- ///////////////////////////////////////////////////////////////////////////////////// -->
<p>Алгоритм построения сбалансированного дерева из n узлов является рекурсивным и состоит из следующих шагов:</p>
<ol>
<li>Взять один узел в качестве корня;</li>
<li>Построить левое поддерево с количеством узлов равным <em>n_left = |n/2</em>| (деление по модулю);</li>
<li>Построить правое поддерево с количеством узлов равным <em>n_right = n-1-n_left</em>.</li>
</ol>
<p>Ниже представлен программный код функции создания идеально сбалансированного дерева из n элементов.</p>
<pre class="highlight"><code data-language="c">
template &#60;class T>
Tree&#60;T>* Tree&#60;T>::balancedTree(int n)
{
	if (n == 0) return NULL;                      //если количество узлов равно 0, то 
	cout << "data = ";                            //выполнение функции завершается
	T dt;                                         //объявляется ключ узла
	cin >> dt;                                    //вводим значение ключа узла
	Tree&#60;T>* tree = new Tree&#60;T>(dt);              //выделяем память корень дерева
tree->addLeftTree(balancedTree(n / 2));       //строим левое поддерево с n/2  
                                            //узлами, рекурсивно вызывая
                                               //функцию (выполняя те же шаги,                      
                                                     //что и для создания корня)
	tree->addRightTree(balancedTree(n - n / 2 - 1));//строим правое поддерево с (n –
                                                       //n/2 – 1) узлами, рекурсивно
								 //вызывая функцию (выполняя те же   
                                                       //шаги, что и для создания корня)
	return tree;
}
</code></pre>
<h2>3. Представление бинарного дерева в виде массива</h2>
<p>Деревья можно представить в виде массивов. Рассмотрим рисунок 12. Массив А - список, элементы которого являются узлами бинарного дерева с корнем А[0]; потомками первого уровня А[1] и A[2]; потомками второго уровня A[3], A[4], A[5] и A[6]; потомками третьего уровня A[7], A[8] и A[9].</p>
<p>Корневой узел имеет индекс, равный нолю, а всем остальным узлам индексы назначаются в порядке, определяемом уровнем расположения.</p>
<!-- /////////////////////////////////////////////RISYNOK  12//////////////////////////////////////// -->
<br>
<div class="gallery">
	<a href="<?php echo $folder_name ?>img/12.png">
	    <img src="<?php echo $folder_name ?>img/12.png" alt="Рисунок 12">
	</a></div><br>
<p class="text-center">Рисунок 12 &ndash; Бинарное дерево для массива А из десяти элементов</p>
<br>
<!-- ///////////////////////////////////////////////////////////////////////////////////// -->
<p>В виде массива проще всего представляется полное бинарное дерево, так как оно всегда имеет строго определенное число вершин на каждом уровне. Вершины можно пронумеровать слева направо последовательно по уровням и использовать эти номера в качестве индексов в одномерном массиве.</p>
<h3>3.1 Недостатки представления бинарного дерева в виде массива</h3>
<p>Несмотря на то, что массивы обеспечивают естественное представление деревьев, возникает проблема, связанная с отсутствующими узлами, которым должны соответствовать неиспользуемые элементы массива. На рисунке 13 массив имеет четыре неиспользуемых элемента, то есть треть занимаемого деревом пространства, а, следовательно, третья часть выделенной для массива памяти не будет использована.</p>
<!-- /////////////////////////////////////////////RISYNOK  13//////////////////////////////////////// -->
<br>
<div class="gallery">
	<a href="<?php echo $folder_name ?>img/13.png">
	    <img src="<?php echo $folder_name ?>img/13.png" alt="Рисунок 13">
	</a></div><br>
<p class="text-center">Рисунок 13 &ndash; Бинарное дерево и представление его структуры в виде массива</p>
<br>
<!-- ///////////////////////////////////////////////////////////////////////////////////// -->
<p>Вырожденное дерево, изображенное на рисунке 14, которое имеет только правые поддеревья, при представлении в виде массива даёт еще худший результат.</p>
<br>
<!-- /////////////////////////////////////////////RISYNOK  14//////////////////////////////////////// -->
<br>
<div class="gallery">
	<a href="<?php echo $folder_name ?>img/14.png">
	    <img src="<?php echo $folder_name ?>img/14.png" alt="Рисунок 14">
	</a></div><br>
<p class="text-center">Рисунок 14 &ndash; Вырожденное бинарное дерево, имеющее только правые поддеревья</p>
<br>
<!-- ///////////////////////////////////////////////////////////////////////////////////// -->

<h3>3.2 Преимущества представления бинарного дерева в виде массива</h3>
<p>Преимущества представляемых массивами деревьев обнаруживаются тогда, когда требуется прямой доступ к узлам. Индексы, идентифицирующие потомков и родителя данного узла, вычисляются в этом случае просто. В таблице 1, расположенной ниже, представлено соответствие бинарного дерева, представленного на рисунке 12, элементам массива А.</p>
<p align="center">Таблица 1 &ndash; Представление бинарного дерева в виде массива</p>
<table>
<tbody>
<tr>
<td width="156">
<b>Уровень</b>
</td>
<td width="156">
<b>Родитель</b>
</td>
<td width="156">
<b>Значение</b> 
</td>
<td width="156">
<b>Левый потомок</b>
</td>
<td width="169">
<b>Правый потомок</b>
</td>
</tr>
<tr>
<td width="156">
<p>0</p>
</td>
<td width="156">
<p>NULL</p>
</td>
<td width="156">
<p>A[0] = 5</p>
</td>
<td width="156">
<p>A[1] = 1</p>
</td>
<td width="169">
<p>A[2] = 3</p>
</td>
</tr>
<tr>
<td width="156">
<p>1</p>
</td>
<td width="156">
<p>A[0] = 5</p>
</td>
<td width="156">
<p>A[1] = 1</p>
</td>
<td width="156">
<p>A[3] = 9</p>
</td>
<td width="169">
<p>A[4] = 6</p>
</td>
</tr>
<tr>
<td width="156">
<p>1</p>
</td>
<td width="156">
<p>A[0] = 5</p>
</td>
<td width="156">
<p>A[2] = 3</p>
</td>
<td width="156">
<p>A[5] = 2</p>
</td>
<td width="169">
<p>A[6] = 4</p>
</td>
</tr>
<tr>
<td width="156">
<p>2</p>
</td>
<td width="156">
<p>A[1] = 1</p>
</td>
<td width="156">
<p>A[3] = 9</p>
</td>
<td width="156">
<p>A[7] = 7</p>
</td>
<td width="169">
<p>A[8] = 0</p>
</td>
</tr>
<tr>
<td width="156">
<p>2</p>
</td>
<td width="156">
<p>A[1] = 1</p>
</td>
<td width="156">
<p>A[4] = 6</p>
</td>
<td width="156">
<p>A[9] = 8</p>
</td>
<td width="169">
<p>NULL</p>
</td>
</tr>
<tr>
<td width="156">
<p>2</p>
</td>
<td width="156">
<p>A[2] = 3</p>
</td>
<td width="156">
<p>A[5] = 2</p>
</td>
<td width="156">
<p>NULL</p>
</td>
<td width="169">
<p>NULL</p>
</td>
</tr>
<tr>
<td width="156">
<p>2</p>
</td>
<td width="156">
<p>A[2] = 3</p>
</td>
<td width="156">
<p>A[6] = 4</p>
</td>
<td width="156">
<p>NULL</p>
</td>
<td width="169">
<p>NULL</p>
</td>
</tr>
<tr>
<td width="156">
<p>3</p>
</td>
<td width="156">
<p>A[3] = 9</p>
</td>
<td width="156">
<p>A[7] = 7</p>
</td>
<td width="156">
<p>NULL</p>
</td>
<td width="169">
<p>NULL</p>
</td>
</tr>
<tr>
<td width="156">
<p>3</p>
</td>
<td width="156">
<p>A[3] = 9</p>
</td>
<td width="156">
<p>A[8] = 0</p>
</td>
<td width="156">
<p>NULL</p>
</td>
<td width="169">
<p>NULL</p>
</td>
</tr>
<tr>
<td width="156">
<p>3</p>
</td>
<td width="156">
<p>A[4] = 6</p>
</td>
<td width="156">
<p>A[9] = 8</p>
</td>
<td width="156">
<p>NULL</p>
</td>
<td width="169">
<p>NULL</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>Для каждого узла дерева индекс его потомков вычисляется по формулам:</p>
<p><em>Индекс левого потомка равен 2*i + 1, который не определён при 2*i+1 &gt; N, где </em><em>N</em><em> &ndash; количество элементов в массиве&nbsp; </em></p>
<p><em>Индекс правого потомка равен 2*i + 2, который не определён при 2*i + 2 &gt; N, где </em><em>N</em><em> &ndash; количество элементов в массиве&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</em></p>
<p>Анализируя выше приведённую таблицу и структуру бинарного дерева, представленного на рисунке 12, видно, что родителем узлов A[1] и A[2] является A[0], родителем A[3] и A[4] &ndash; A[1], родителем A[5] и A[6] &mdash; A[2], родителем A[7] и A[8] &ndash; A[3]. Таким образом, общая формула для вычисления родителя узла A[i] следующая:</p>
<p><em>Индекс родителя равен (i-1)/2, который не определен при i = 0 </em></p>

<h3>3.3 Создание бинарного дерева из значений, заданных векторе массива</h3>
<p>В программном коде, представленном ниже, производится составление дерева по значениям заданного вектора с использованием определенных выше формул нахождения левого и правого потомков.</p>
<pre class="highlight"><code data-language="c">
vector&#60;int> arr = { 19, 33, 13, 17, 3, 31, 35, 18, 15 }; //определяется вектор с девятью 
                                                         //элементами типа int
Tree&#60;int>* tree = new Tree&#60;int>(arr.at(0));              //добавляется в дерево корень- 
                                                         //первый элемент вектора
for (int i = 0; i < arr.size(); i++)
{
    int left = 2 * i + 1;                                //по формуле вычисляется индекс 
                                                         //левого потомка
    int right = left + 1;                                //по формуле вычисляется индекс 
                                                         //правого потомка
    if (left < arr.size())
    {
       tree->findElement_insertLeft(tree, arr.at(i), arr.at(left));//ищется ранее 
                                                                   //добавленный в дерево
                                                                   //элемент - родитель 
                                                                   //(arr.at(i)) и 
                                                                   //добавляется к нему
                                                                   //левый потомок с  
                                                                   //вычисленным ранее  
                                                                   //индексом left
    }
    if (right < arr.size())
    {
     tree->findElement_insertRight(tree, arr.at(i), arr.at(right));//ищется ранее 
                                                                   //добавленный в дерево 
                                                                   //элемент - родитель 
                                                                   //(arr.at(i)) и         
                                                                   //добавляется к нему
                                                                   //правый потомок с 
                                                                   //вычисленным ранее  
                                                                   //индексом right
    }
}
</code></pre>
<h2>Список литературы:</h2>
<ol>
<li>Кен Браунси: Структуры данных в C++. Краткий справочник, с.153.</li>
<li>Роберт Седжвик: Фундаментальные алгоритмы на C++, с.218-239.</li>
<li>Топп Уильям, Форд Уильям. Структуры данных в C++, с.228.</li>
<li>Никлаус Вирт &laquo;Алгоритмы и структуры данных&raquo;, с.69.</li>
</ol>

</main><!--end main-->
</div><!--end .row-->
<?php include ($r_base."assets/php_modules/footer.tpt.php"); ?>  
</div><!--end .container-fluid-->
<?php include ($r_base."assets/php_modules/scripts.tpt.php"); ?>
</body>
</html>