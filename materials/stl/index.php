<?php
include ("index.config.php");
include ($r_base."assets/php_modules/addons.php");

?>
<!DOCTYPE html>
<html lang="ru">
<head>
<?php include ($r_base."assets/php_modules/head.tpt.php"); ?>
</head>
<body>
<div class='container-fluid'>
<?php include ($r_base."assets/php_modules/header.tpt.php"); ?>  
<div class="row">
<?php include ($r_base."assets/php_modules/aside.tpt.php"); ?>
<main class="col-md markdown-body text-justify">
<p>STL &mdash; Standard Template Library, стандартная библиотека шаблонов состоит из двух основных частей:</p>
<ol>
<li>Набор контейнерных классов;</li>
<li>Набор обобщённых алгоритмов.</li>
</ol>
<h2 id="1">1 Контейнеры</h2>
<p><em>Контейнеры</em> &mdash; наборы однотипных объектов. Контейнерные классы являются шаблонными и могут хранить объекты любых типов данных. Эти объекты должны допускать копирование и присваивание. Встроенные типы этим требованиям удовлетворяют; то же самое относится к классам, если конструктор копирования или операция присваивания не объявлены в них закрытыми или защищенными. Контейнеры STL реализуют основные структуры данных, используемые при написании программ. Классификация контейнеров приведена на рисунке 1.</p>
<div class="gallery">
	<a href="<?php echo $folder_name ?>img/1.jpg">
	    <img src="<?php echo $folder_name ?>img/1.jpg" alt="Рисунок 1">
	</a>
</div>
<p class="text-center lead">Рисунок 1 - Классификация контейнеров</p>
<h3>1.1 Последовательные контейнеры</h3>
<p>Последовательные контейнеры хранят конечное количество однотипных объектов в виде непрерывной последовательности. К базовым контейнерам относятся векторы (vector), списки (list) и двусторонние очереди (deque). Специализированные адаптеры реализованы на основе базовых &mdash; стеки (stack), очереди (queue) и очереди с приоритетом (priority_queue).</p>
<p>Для использования контейнера необходимо подключить соответствующий заголовочный файл:</p>
<p>Листинг 1<br /> Объявление контейнерных классов</p>
<pre class="highlight"><code data-language="c">#include &#60;vector&#62;
#include &#60;list&#62;
#include "Time.h"
/*Some code here*/
vector &#60;double&#62; vect; //Вектор, содержащий объекты типа double
list &#60;Time&#62; clock; //Список, содержащий объекты типа Time</code></pre>

<h2 id="2">2 Общие свойства контейнеров</h2>
<p>Обратимся к таблице 1 для ознакомления с &nbsp;унифицированными типами, определёнными в STL.</p>
<table>
<tbody>
<tr>
<td>
<p>size_type</p>
</td>
<td>
<p>Тип индексов, счётчиков и т.д.</p>
</td>
</tr>
<tr>
<td>
<p>iterator</p>
</td>
<td>
<p>Итератор</p>
</td>
</tr>
<tr>
<td>
<p>const_iterator</p>
</td>
<td>
<p>Константный итератор (значение элемента изменять запрещено)</p>
</td>
</tr>
<tr>
<td>
<p>reverse_iterator</p>
</td>
<td>
<p>Обратный итератор</p>
</td>
</tr>
<tr>
<td>
<p>const_reverse_iterator</p>
</td>
<td>
<p>Константный обратный итератор</p>
</td>
</tr>
<tr>
<td>
<p>reference</p>
</td>
<td>
<p>Ссылка на элемент</p>
</td>
</tr>
<tr>
<td>
<p>const_reference</p>
</td>
<td>
<p>Константная ссылка на элемент</p>
</td>
</tr>
<tr>
<td>
<p>key_type</p>
</td>
<td>
<p>Тип ключа в ассоциативных контейнерах</p>
</td>
</tr>
<tr>
<td>
<p>key_compare</p>
</td>
<td>
<p>Тип функции сравнения двух ключей (в ассоц. конт.)</p>
</td>
</tr>
</tbody>
</table>
<p>Таблица 1. Унифицированные типы, определённые в STL</p>
<p>Обратимся к таблице 2 для ознакомления с операциями и методами, доступными для всех контейнеров.</p>
<table>
<tbody>
<tr>
<td>
<p>Операции равенства и неравенства</p>
</td>
<td>
<p>Возвращают true или false</p>
</td>
</tr>
<tr>
<td>
<p>Операция присваивания</p>
</td>
<td>
<p>Копирует один контейнер в другой</p>
</td>
</tr>
<tr>
<td>
<p>clear()</p>
</td>
<td>
<p>Удаление всех элементов</p>
</td>
</tr>
<tr>
<td>
<p>insert</p>
</td>
<td>
<p>Добавление одного элемента или диапазона</p>
</td>
</tr>
<tr>
<td>
<p>erase</p>
</td>
<td>
<p>Удаление одного элемента или диапазона</p>
</td>
</tr>
<tr>
<td>
<p><em>size_type</em> size()</p>
</td>
<td>
<p>Возвращает число элементов</p>
</td>
</tr>
<tr>
<td>
<p><em>size_type</em> max_size()</p>
</td>
<td>
<p>Возвращает максимально допустимый размер контейнера</p>
</td>
</tr>
<tr>
<td>
<p><em>bool</em> empty()</p>
</td>
<td>
<p>Возвращает true если контейнер пуст</p>
</td>
</tr>
<tr>
<td>
<p><em>iterator</em> begin()</p>
</td>
<td>
<p>Возвращает итератор на начало контейнера</p>
</td>
</tr>
<tr>
<td>
<p><em>iterator</em> end()</p>
</td>
<td>
<p>Возвращает итератор на конец контейнера</p>
</td>
</tr>
<tr>
<td>
<p><em>reverse_iterator</em> rbegin()</p>
</td>
<td>
<p>Возвращает обратный итератор на начало <u>обратной</u> последовательности</p>
</td>
</tr>
<tr>
<td>
<p><em>reverse_iterator</em> rend()</p>
</td>
<td>
<p>Возвращает обратный итератор на конец <u>обратной</u> последовательности</p>
</td>
</tr>
</tbody>
</table>
<p>Таблица 2. Операции и методы, общие для всех контейнеров</p>
<h2 id="3">3 Итераторы</h2>
<p>Итераторы &mdash; это обобщение концепции указателей: они ссылаются на элементы контейнера. Для работы с итераторами необходимо подключить библиотеку &lt;iterator&gt;</p>
<p>Тип iterator определён для всех контейнерных классов, но реализация для разных классов разная. Основные операции итераторов:</p>
<ol>
<li>Разыменовывание: если p &mdash; итератор, то *p &mdash; значение объекта, на который он ссылается.</li>
<li>Присваивание одного итератора другому.</li>
<li>Сравнение на равенство и неравенство (== и !=)</li>
<li>Перемещение итератора по элементам контейнера с помощью инкремента (p++ и ++p)</li>
</ol>
<p>Из-за различий реализации объявление объектов типа iterator должно сопровождаться указанием области видимости в форме имя_шаблона::, например:</p>
<p>Листинг 2<br /> Объявление итераторов</p>
<pre class="highlight"><code data-language="c">#include &#60;vector&#62;
#include &#60;list&#62;
#include &#60;iterator&#62; //подключение библиотеки итераторов
//Итератор для вектора с объектами типа double
vector&#60;double&#62;::iterator vectIter;
//Реверсивный итератор для списка с объектами типа Time
list&#60;Time&#62;::reverse_iterator listIter;</code></pre>
<p>Реализация циклов просмотра элементов контейнеров тоже имеет свою специфику. Так, если i &mdash; некоторый итератор, то вместо привычной формы:</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (i = 0; i &lt; n; i++) используется:<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (i = first; i != last; i++), где first &mdash; значение итератора, указывающее на первый элемент в контейнере, а last &mdash; значение итератора, указывающее на воображаемый элемент за последним элементом.</p>
<p>Для всех контейнерных классов определены унифицированные методы begin() для получения адреса first и end() для получения адреса last.</p>
<p>Типы итераторов в STL:</p>
<ol>
<li>Ввода &ndash; поддерживают операции равенства, разыменовывания и автоинкремента: ==, !=, ++i, i++, *i++.<br /> Могут использоваться для однопроходных алгоритмов, которые считывают данные в одном направлении.<br /> Специальным случаем итератора ввода является istream_iterator.</li>
<li>Вывода &ndash; поддерживают разыменовывание, допустимое только с левой стороны, присваивание, и инкремент:<br /> ++i, i++, *i=t, *i++ = t.</li>
<li>Однонаправленные &ndash; поддерживают все операции итераторов ввода-вывода и позволяют без ограничений применять присваивание. Для них из i == j следует ++i == ++j, что не всегда истинно для итераторов ввода, то есть такие итераторы сохраняют свою позицию внутри контейнера, поэтому их можно использовать в алгоритмах с многократным проходом</li>
<li>Двунаправленные &ndash; поддерживают все операции однонаправленных итераторов, а также проход контейнера в обоих направлениях, т.е. декремент: --i, i&ndash;, *i&ndash;.</li>
<li>Произвольного доступа &ndash; поддерживают все операции двунаправленных итераторов, а также операции сравнения и адресной арифметики, т.е. непосредственный доступ по индексу:<br /> i+=n, a+n, i-=n, a-n, i-j, i[n], i&lt;j, i&lt;=j, i&gt;=j, i&gt;j.</li>
</ol>
<h3>3.1 Прямой и обратный итераторы</h3>
<p>В STL библиотеках помимо обычных (прямых) итераторов iterator поддерживаются обратные итераторы reverse_iterator. Обратный итератор применяется так же, как прямой. Разница состоит в реализации операторов перехода к следующему и предыдущему элементам. Для прямого итератора оператор ++ дает доступ к следующему элементу контейнера, тогда как для обратного &ndash; к предыдущему.</p>
<h2 id="4">4 Использование последовательных контейнеров</h2>
<p>К основным контейнерам относятся векторы (vector), списки (list) и двусторонние очереди (deque). Для использования контейнера необходимо подключить соответствующий заголовочный файл:</p>
<pre class="highlight"><code data-language="c">#include&#60;vector&#62;
#include&#60;list&#62;
#include&#60;deque&#62;
</code></pre>

<p><em>Вектор</em> является аналогом обычного массива, за исключением того, что он автоматически выделяет и освобождает память по мере необходимости. Контейнер эффективно обрабатывает произвольную выборку элементов с помощью операции индексации [] или метода at. Однако вставка элемента в любую позицию, кроме конца вектора, неэффективна. Для этого потребуется сдвинуть все последующие элементы путем копирования их значений. По этой же причине неэффективным является удаление любого элемента, кроме последнего.</p>
<p><em>Список</em> организует хранение объектов в виде двусвязного списка. Вставка и удаление работают эффективно для любой позиции элемента в списке. Однако список не поддерживает произвольного доступа к своим элементам: например, для выборки n-го элемента нужно последовательно выбрать предыдущие п-1 элементов.</p>
<p><em>Двусторонняя очередь</em> во многом аналогична вектору, элементы хранятся в непрерывной области памяти. Но в отличие от вектора двусторонняя очередь эффективно поддерживает вставку и удаление первого элемента (так же, как и последнего).</p>
<p>В листинге 3 представлены способы определить объект для последовательного контейнера.</p>
<p>Листинг3<br /> Способы определения объекта для<br /> последовательного контейнера</p>
<ol>
<li>Создать пустой контейнер<br /> vector&lt;int&gt; vec1;<br /> list&lt;double&gt; lst1;</li>
<li>Задать контейнер заданного размера и<br /> инициализировать его элементы<br /> значениями по умолчанию<br /> vector&lt;int&gt; vec2(50);<br /> list&lt;double&gt; lst2(75);</li>
<li>Задать контейнер заданного размера и<br /> инициализировать его элементы заданным значением<br /> vector&lt;int&gt; vec3(133, 7);<br /> list&lt;double&gt; lst3(14, 8.8);</li>
<li>Задать контейнер и инициализировать его элементы<br /> значениями диапазона (first, last) элементов<br /> другого контейнера<br /> int arr[8] = {0, 20, 1, 22, 8 -144, 6, -50, 100, 45};<br /> vector&lt;int&gt; vec4(arr, arr+9);<br /> list&lt;int&gt; lst4(vec4.begin()+2, vec4.end());</li>
<li>Задать контейнер и инициализировать его элементы<br /> значениями элементов другого однотипного контейнера<br /> list&lt;int&gt; lst5(10, 6);<br /> list&lt;int&gt; lst6(lst5);</li>
</ol>
<p>Обратимся к таблице 3.</p>
<table>
<tbody>
<tr>
<td>
<p>push_back(T&amp; key)</p>
</td>
<td>
<p>Добавить в конец</p>
</td>
<td>
<p>vector, list, deque</p>
</td>
</tr>
<tr>
<td>
<p>pop_back()</p>
</td>
<td>
<p>Удалить из конца</p>
</td>
<td>
<p>vector, list, deque</p>
</td>
</tr>
<tr>
<td>
<p>push_front(T&amp; key)</p>
</td>
<td>
<p>Добавить в начало</p>
</td>
<td>
<p>list, deque</p>
</td>
</tr>
<tr>
<td>
<p>pop_front()</p>
</td>
<td>
<p>Удалить из начала</p>
</td>
<td>
<p>list, deque</p>
</td>
</tr>
<tr>
<td>
<p>insert</p>
</td>
<td>
<p>Добавить в произвольное место</p>
</td>
<td>
<p>vector, list, deque</p>
</td>
</tr>
<tr>
<td>
<p>erase</p>
</td>
<td>
<p>Удалить из произвольного места</p>
</td>
<td>
<p>vector, list, deque</p>
</td>
</tr>
<tr>
<td>
<p>[], at</p>
</td>
<td>
<p>Доступ к произвольному элементу</p>
</td>
<td>
<p>vector, deque</p>
</td>
</tr>
<tr>
<td>
<p>swap</p>
</td>
<td>
<p>Обмен списков/векторов</p>
</td>
<td>
<p>vector, list</p>
</td>
</tr>
<tr>
<td>
<p>clear()</p>
</td>
<td>
<p>Очистка списков/векторов</p>
</td>
<td>
<p>vector, list</p>
</td>
</tr>
<tr>
<td>
<p>splice</p>
</td>
<td>
<p>Сцепка двух списков</p>
</td>
<td>
<p>list</p>
</td>
</tr>
</tbody>
</table>
<p>Таблица 3. Методы, которые поддерживают последовательные контейнеры</p>
<p>Метод insert имеет несколько реализаций:</p>
<ol>
<li>iterator insert(iterator pos, const T&amp; key); &ndash; вставка элемента key в позицию, на которую указывает pos. Возвращает итератор на новый элемент.</li>
<li>void insert(iterator pos, size_type n, const T&amp; key); &ndash; вставка n элементов со значением key начиная с позиции, на которую указывает pos.</li>
<li>template &lt;class InputIter&gt;<br /> void insert(iterator pos, InputIter first, InputIter last); &ndash; Вставка элементов из диапазона ..last начиная с позиции, на которую указывает pos.</li>
</ol>
<p>Пример использования метода insert() представлен в листинге 4.</p>
<p>Листинг 4<br /> Использование метода insert()</p>
<pre class="highlight"><code data-language="c">void main()
{
  создать вектор из 5 элементов, проинициализировать элементы нулями
  vector &#60;int&#62;v1(5,0);
  int m[5]={1,2,3,4,5}; массив из 5 элементов
  вставить элемент со значением 100 в начало вектора:
  v1.insert(v1.begin(),100);
  вставить два элемента со значением 200 после первого элемента вектора:
  v1.insert(v1.begin()+1,2,200);
  вставить элементы из массива m после третьего элемента:
  v1.insert(v1.begin()+3,m,m+5); m - указатель на первый, +5 т.к. пять элементов
  вставить элемент 100 в конец вектора:
  v1.insert(v1.end(),100);
  вывести вектор на печать:
  for(int i=0;i&#60;v1.size();i++)
    cout &#60;&#60; v1[i] &#60;&#60;' ';
}
</code></pre>

<p>Метод erase также имеет несколько реализаций:</p>
<ol>
<li>iterator erase(iterator pos); &ndash; Удаляет элемент в позиции, на которую указывает итератор pos.</li>
<li>iterator erase(iterator first, iterator last); &ndash; Удаляет диапазон элементов.</li>
</ol>
<p>Пример использования метода erase() представлен в листинге 5.</p>
<p>Листинг 5<br /> Использование метода erase()</p>
<pre class="highlight"><code data-language="c">int main()
{
  vector&#60;int&#62; v1;создать пустой вектор
  int m[5] = {1,2,3,4,5};
  int n,a;
  cout &#60;&#60; "insert n: "; cin &#62;&#62; n;
  for(int i=0; i &#60; n; i++)
  {
    cin >> a;
    добавить в конец вектора элемент со значением а
    v1.push_back(a);
  }
  вывод вектора
  for (int i=0; i &#60; v1.size(); i++)
    cout &#60;&#60; v1[i] &#60;&#60; ' ';
  cout &#60;&#60; endl;
  /*удалить элемент из начала вектора и итератор поставить на начало вектора*/
  vector&#60;int&#62;::iterator iv=v1.erase(v1.begin());
  cout &#60;&#60; *iv &#60;&#60; '\n';вывод первого элемента
  вывод вектора
  for (int i=0; i &#60; v1.size(); i++)
    cout &#60;&#60; v1[i] &#60;&#60; ' ';
}</code></pre>

<h3>4.1 Адаптеры контейнеров</h3>
<p>Стек, очередь и очередь с приоритетами не являются самостоятельными классами, а реализованы на основе базовых, поэтому они называются адаптерами контейнеров.</p>
<p>По умолчанию прототипом является класс deque.</p>
<h3>4.1.1 Стек</h3>
<p>Заголовочный файл &lt;stack&gt;</p>
<p>Объявление stack&lt;int&gt; s; создаёт стек на основе двусторонней очереди. Если необходимо создать стек на основе списка, то используется stack&lt;int, list&lt;int&gt;&gt; s;</p>
<p>Такая реализация необходима для того, чтобы ограничить функционал класса только теми методами, которые необходимы новому классу. Стек не поддерживает произвольный доступ к элементам, а также итераторы.</p>
<p>Доступные методы:</p>
<ol>
<li>push() &ndash; добавление в конец;</li>
<li>pop() &ndash; удаление из конца;</li>
<li>top() &ndash; значение текущего элемента стека;</li>
<li>size() &ndash; количество элементов;</li>
<li>empty() &ndash; проверяет пуст ли стек.</li>
</ol>
<h3>4.1.2 Очередь</h3>
<p>Заголовочный файл &lt;queue&gt;</p>
<p>Объявление queue&lt;int&gt; q; создаёт очередь на основе двусторонней очереди. Возможна реализация на основе списка</p>
<p>Доступные методы:</p>
<ol>
<li>push() &ndash; добавление в конец;</li>
<li>pop() &ndash; удаление из начала;</li>
<li>front() &ndash; значение первого элемента очереди;</li>
<li>back() &ndash; значение последнего элемента очереди;</li>
<li>size() &ndash; количество элементов;</li>
<li>empty() &ndash; проверяет пуста ли очередь.</li>
</ol>
<h3>4.1.3 Очередь с приоритетами</h3>
<p>Заголовочный файл &lt;queue&gt;</p>
<p>Объявление priority_queue&lt;int&gt; p_q; создаёт очередь с приоритетами на основе вектора. Возможна реализация на основе списка.</p>
<p>Отличие от обычной очереди в том, что для извлечения выбирается максимальный элемент из хранимых. Поэтому после каждого изменения максимальный элемент сдвигается в начало контейнера.</p>
<p>Доступные методы:</p>
<ol>
<li>push() &ndash; добавление в конец;</li>
<li>pop() &ndash; удаление из начала;</li>
<li>top() &ndash; значение первого элемента очереди;</li>
<li>size() &ndash; количество элементов;</li>
<li>empty() &ndash; проверяет пуста ли очередь.</li>
</ol>
<p>Пример использования очереди с приоритетами представлен в листинге 6.</p>
<p>Листинг 6<br /> Использование priority_queue</p>
<pre class="highlight"><code data-language="c">int main()
{
  priority_queue&#60;int&#62; pq; Очередь с приоритетами
  добавление элементов
  pq.push(50);
  pq.push(3000);
  pq.push(-5);
  pq.push(90);
  pq.push(0);
  while(!pq.empty()) пока очередь не пуста
  {
    cout << pq.top() << ' '; вывести первый элемент
    pq.pop(); удалить первый элемент
  }
}</code></pre>
<p>Результат работы:<br /> 3000 90 50 0 -5</p>
<h2 id="5">Список литературы</h2>
<ol>
<li>Ноткин А.М. Объектно-ориентированное программирование: ООП в C++ : учебное пособие, 2013 г. &mdash;230 с.</li>
<li>Стенли Б. Липпман. C++ для начинающих. &mdash;1195 c.</li>
<li>Павловская Т.А. C/C++. Программирование на языке высокого уровня, 2007 г. &mdash;461 с.</li>
</ol>
</main><!--end main-->
</div><!--end .row-->
<?php include ($r_base."assets/php_modules/footer.tpt.php"); ?>  
</div><!--end .container-fluid-->
<?php include ($r_base."assets/php_modules/scripts.tpt.php"); ?>
</body>
</html>