<?php
include ("index.config.php");
include ($r_base."assets/php_modules/addons.php");
?>
<!DOCTYPE html>
<html lang="ru">
<head>
    <?php include ($r_base."assets/php_modules/head.tpt.php"); ?>
</head>
<body>
<div class='container-fluid'>
<?php include ($r_base."assets/php_modules/header.tpt.php"); ?>  
<div class="row">
<?php include ($r_base."assets/php_modules/aside.tpt.php"); ?>
<main class="col-md markdown-body">
<p>&#8226; Поиск — обработка некоторого множества данных с целью выявления подмножества данных, соответствующего критериям поиска.</p>
<p>&#8226; Все алгоритмы поиска делятся на два вида:</p>
<ul>
    <li>поиск в неупорядоченном множестве данных;</li>
    <li>поиск в упорядоченном множестве данных.</li>
</ul>

<h2 id="1">1. Поиск в неупорядоченном множестве данных</h2>
<h3>1.1 Линейный поиск</h3> 
<div class="block__text text-justify">
    &#8226; Алгоритм заключается в том, что для поиска заданного элемента из множества, происходит непосредственное сравнивание каждого элемента этого множества с искомым. На рисунке 1 приведен пример, где искомым элементом, является элемент со значением равным 77. [1]
    <img src="<?php echo $folder_name ?>img/1schm.jpg"  alt="Рисунок 1">
    <p style="text-align: center;">Рисунок 1 - Алгоритм линейного поиска</p>
    &#8226; Выполнение алгоритма можно ускорить за счет введения переменной логического типа, значение которой изменится на противоположное, как только встретится элемент равный заданному.
    <div class="spollers__item">
        <div class="spollers__title spoller closeall">Фрагмент алгоритма Линейного поиска на алгоритмическом языке С++ (развернуть)...</div>
            <div class="spollers__text">
                <pre class="highlight"><code data-language="c" id="">int LINEsearch(int arr[], int size, int key) // функция принимает значения: массив, размер массива и искомое значение
{
for (int  i = 0 ;i  &#60;  size ; i++)
{
if (arr[i] == key) return i; // если условие выполняется в main возвращается индекс элемента исходного множества, который равен заданному ключу
}
return -1; // если условие не выполняется, возвращается -1
}</code></pre>
        </div>
    </div>
    
</div>
<h3>1.2 Прямой поиск подстроки в строке</h3> 
<div class="block__text text-justify">
    &#8226; Алгоритм заключается в посимвольном сравнении заданного текста с искомой подстрокой. Алгоритм выполняет сравнение первого символа текста с первым символом подстроки, затем второго символа текста со вторым символом подстроки и так далее. Если все пары сравниваемых символов совпали, то фиксируется факт нахождения подстроки. В противном случае производится «сдвиг» подстроки на одну позицию вправо, и повторяется посимвольное сравнение, то есть сравнивается второй символ текста с первым символом подстроки, третий символ текста со вторым символом подстроки и так далее. «Сдвиги» подстроки повторяются до тех пор, пока последний символ подстроки не достигнет последнего символа текста – в этом случае алгоритм выдает сообщение о том, что заданной подстроки в тексте не найдено. Иначе происходит полное совпадение символов подстроки с текстом, то есть подстрока в тексте найдена. Алгоритм метода прямого поиска заданной подстроки в исходном тексте приведен на рисунке 2.
    <img src="<?php echo $folder_name ?>img/2schm.png" alt="Рисунок 2">
    <p style="text-align: center;">Рисунок 2 – Алгоритм прямого поиска заданной подстроки в исходном тексте</p>
    &#8226; Алгоритм прямого поиска заданной подстроки в исходном тексте работает эффективно, если несовпадение пары символов происходит после незначительного количества сравнений. При достаточно большом множестве символов это довольно частый случай. Например, для текстов, состоящих из 128 символов алфавита, несовпадение будет обнаруживаться после одной - двух проверок. В сложных случаях алгоритм малоэффективен, так как его сложность будет пропорциональна <code class="highlight">O((N – M)·M)</code>. 
    <div class="spollers__item">
        <div class="spollers__title spoller closeall">Фрагмент алгоритма Алгоритм прямого поиска заданной подстроки в исходном тексте на алгоритмическом языке С++ (развернуть)...</div>
            <div class="spollers__text">
                <pre class="highlight"><code data-language="c" id="">int search(string str, string substr) //функция принимает значения: строка и подстрока
{		
int strl, substrl, res = -1;
strl = str.size(); substrl = substr.size(); //длина строки и подстроки
if (strl != 0 && substrl != 0){
for (int i = 0; i &#60; strl - substrl +1; i++){	//Проход по строке
for (int j = 0; j &#60; substrl; j++){		//Проход по подстроке
if (substr[j] != str[i + j]) 
{
    break;
    }
else if(j == substrl - 1) /*Если это последний символ в подстроке, то строка найдена*/
{
        res = i;					
        break;					
            }
    }
}
return res;
}
return -1;
}</code></pre>
        </div>
    </div>
</div>
    
<h3>1.3 Алгоритм Боуера–Мура – поиск заданной подстроки в исходной строке</h3> 
<div class="block__text text-justify">
    <p>&#8226; Алгоритм сравнивает символы заданной подстроки с исходной строкой, при помощи специальной таблицы переноса - Shift, которая формируется на основе заданной подстроки [3]. Алгоритм заполнения таблицы переноса показан на рисунке 3 и выполняется по следующим шагам:</p>
    <ol>
        <li>В первую строку таблицы, заносятся символы заданной подстроки – subctr. </li>
        <li>Во вторую строку таблицы Shift для каждого символа из первой строки этой таблицы заносится расстояние от рассматриваемого символа до последнего символа подстроки subctr, не учитывая этот последний символ. Такое расстояние для символа называется величиной переноса, для каждого символа  <b>величина переноса</b> имеет свое значение (кроме повторяющихся символов).
<br>
        Например, задана подстрока subctr: ABBC. Не учитывая последний символ подстроки – это символ С, расставляем для остальных символов <b>величину переноса</b>. Для символа B (он стоит на следующем месте, после конечного символа подстроки )  <b>величина переноса</b> составит - 1.
</li>
        <li>Если очередной символ заданной подстроки повторяется, то в расчете величины переноса в таблицу Shift заносится ранее вычисленное значение величины переноса для этого символа;<br>Таким образом, для повторяющегося символа В из подстроки ABBC,  <b>величина переноса</b> также составит -1.</li>
        <li> <b>Величина переноса</b> для символа А из заданной подстроки ABBC равна 3;</li>
        <li> <b>Величина переноса</b> для конечного символа подстроки равна длине подстроки;</li>
        <li> <b>Величина переноса</b> для любого символа «*», не входящего в подстроку, равна длине подстроки.</li>
    </ol>
    
    <img src="<?php echo $folder_name ?>img/3schm.png" alt="Рисунок 3" class="img-fluid">
    <p style="text-align: center;">Рисунок 3 – Заполнение таблицы переноса </p>
    &#8226; Например, исходная строка str содержит следующие символы: AGССABBC.
    <br>
    &#8226; Заданная подстрока содержит следующие символы: ABBC.
    <br>
    &#8226; Составляется таблица проверки на вхождение подстроки в строку, для этого строка и подстрока размещаются друг под другом, как показано на рисунке 4.
    <br>
    &#8226; Подстрока рассматривается, начиная с её последнего символа, для данного примера – это символ С. Позиция Pos этого символа по отношению к исходной строке равна 3, поскольку нумерация символов в строке начинается с нуля.
    <br>
    &#8226; Последний символ С подстроки находится под символом С строки и совпадает с ним. Далее, рассматривается символ В заданной подстроки, который не совпал с символом С исходной строки. Следовательно, необходимо перенести подстроку вдоль строки вправо, на число символов, которое равно числу shift для этого символа из таблицы переноса на рисунке 3.
    <img src="<?php echo $folder_name ?>img/4schm.png" alt="Рисунок 4" class="img-fluid">
    <p style="text-align: center;">Рисунок 4 - Алгоритм Боуера–Мура поиска подстроки в строке</p>
    &#8226; Величина переноса вычисляется по формуле (1): 
    <br>
    <code class="highlight">Pos = Pos + Shift[(int)(«C»)] = 3+4 = 7 (1)</code>; 
    <br>
    <ul>
        <li><code class="highlight">Pos</code> – позиция последнего символа подстроки по расположению относительно исходной строки;</li>
        <li><code class="highlight">Shift («C»)</code> – величина переноса подстроки в соответствии с таблицей на рисунке 3 для символа С.</li>
    </ul>
    <p>&#8226; После переноса заданной подстроки вдоль исходной строки, вновь сравниваются символы исходной строки с символами заданной подстроки (рисунок 5), начиная с конца подстроки, как и на предыдущем шаге.</p>
    <img src="<?php echo $folder_name ?>img/5schm.png" alt="Рисунок 5" class="img-fluid">
    <p style="text-align: center;">Рисунок 5 - Алгоритм Боуера–Мура поиска подстроки в строке</p>
    <p>&#8226; Если заданная подстрока найдена в исходной строке, то можно вычислить позицию первого символа подстроки по отношению к исходной строке, которая вычисляется по формуле (2): </p>
    <code class="highlight">Index=Pos-lenght+1; (2)</code>; 
    <ul>
        <li><code class="highlight">Index</code> – индекс символа в исходной строке, начиная с которого, все символы заданной подстроки совпадают с символами в исходной строке;</li>
    </ul>
    <p>&#8226; Для заданного примера из формулы (2) следует, что этот индекс равен:</p>
    <code class="highlight">Pos – l + 1 = 7-4+1 = 4</code>

    <div class="spollers__item">
    <div class="spollers__title spoller closeall">Фрагмент алгоритма Боуера - Мура на алгоритмическом языке С++ (развернуть)...</div>
        <div class="spollers__text">
            <pre class="highlight"><code data-language="c" id="">int BMsearch(string str, string substr) {
int strl, substrl, res = -1;
strl = str.size(); substrl = substr.size();
if (strl != 0 && substrl != 0) {
int  i, Pos;
int  bias[256]; 			//массив смещения
for (i = 0; i < 256; i++) {
bias[i] = substrl;	//присвоить каждому элементу массива смещения длину подстроки
}
for (i = substrl - 2; i >= 0; i--) {	//Корректируем массив смещения
if (bias[int((unsigned char)substr[i])] == substrl) {
    bias[int((unsigned char)substr[i])] = substrl - i - 1;
}
}
Pos = substrl - 1; //позиция последнего символа подстроки относительно строки
while (Pos < strl) {	//выполняется тело цикла, пока есть подстрока в строке
if (substr[substrl - 1] != str[Pos]) {//последний символ подстроки и символ стороки 
Pos+=bias[int((unsigned char)str[Pos])];//сдвиг по таблице
}
else {
    for (i = substrl - 1; i >= 0; i--) {	//проход по символам подстроки начиная с предпоследнего
        if (substr[i] != str[Pos - substrl + i + 1]){		//сравнение символа подстроки и символа стороки 
            Pos += bias[int((unsigned char)str[Pos - substrl + i + 1])];
            break;
        }
else if (i == 0) {	//если прошли всю подстроку 
    return Pos - substrl + 1;	//считаем индекс
        }
    }
}
}
}
return res;
}</code></pre>
        </div>
    </div>
</div><!-- End block__text-->

<h2 id="2">2. Поиск в упорядоченном множестве данных</h2>
<h3>2.1 Бинарный поиск</h3> 
<div class="block__text text-justify">
    &#8226; Алгоритм поиска заданного элемента в упорядоченном множестве данных заключается в отслеживании наименьшего и наибольшего индексов элементов массива — <code class="highlight">min</code> и <code class="highlight">max</code>, которые равны первому (нулевому) и последнему индексам заданного множества соответственно. Затем вычисляется индекс элемента - <code class="highlight">mid</code>, а также значение элемента, имеющего этот индекс. Значение <code class="highlight">mid</code>, находится через функцию целочисленного деления пополам между значениями min и max. Если искомое значение элемента множества меньше значения элемента множества с индексом <code class="highlight">mid</code>, то алгоритм начинает новый поиск в левой половине множества; если оно больше — новый поиск ведется в правой половине множества. Если же искомое значение элемента множества равно элементу с индексом mid, то алгоритм возвращает его индекс. На рисунке 5 показан алгоритм бинарного поиска заданного элемента множества, равного числу 77. 
    <img src="<?php echo $folder_name ?>img/6schm.jpg" alt="Рисунок 5">
    <p style="text-align: center;">Рисунок 5 – Алгоритм бинарного поиска </p>
    &#8226; Таким образом, на каждом шаге алгоритма элементы множества, среди которых содержится искомый, делятся пополам нацело. Если количество элементов заданного множества равно <code class="highlight">N</code>, то после прохождения <code class="highlight">O(log N)</code> - шагов в части массива, где может располагаться заданный элемент, останется только одно значение, при этом алгоритм найдет искомый элемент или обнаружит, что элемента с заданным значением во множестве нет. [4]
    <div class="spollers__item">
        <div class="spollers__title spoller closeall">Фрагмент алгоритма Бинарного поиска на алгоритмическом языке С++ (развернуть)...</div>
            <div class="spollers__text">
                <pre class="highlight"><code data-language="c" id="">int BINsearch(int arr[], int n, int key)
{
bool flag = false;
int l = 0; // левая граница множества
int r = n; // правая граница множества
int mid;

while ((l &#60;= r) && (flag != true)) 
{
mid = (l + r) / 2; // вычисляется индекс элемента mid

if (arr[mid] == key) flag = true; /*сравнивается заданный ключ с элементом mid*/
if (arr[mid] &#62; key) r = mid - 1; /* Если искомое значение элемента множества меньше значения элемента множества с индексом mid, то алгоритм начинает новый поиск в левой половине множества;*/	
else l = mid + 1; /* Иначе, новый поиск ведется в правой половине множества.*/
}
return mid;
}</code></pre>
            </div>
        </div>
</div>

<h3>2.2 Интерполяционный поиск</h3> 
<div class="block__text text-justify">
    &#8226; Алгоритм бинарного поиска ищет заданный элемент множества через функцию целочисленного деления пополам количества элементов множества.  Алгоритм интерполяционного поиска ускоряет процесс, используя формулу 3, которая определяет индекс искомого элемента в массиве по его значению.[5]
    <img src="<?php echo $folder_name ?>img/7schm.png"  alt="Формула (3)"> 
    <p class="text-center">(3)</p>
    <ul>
        <li><code class="highlight">mid</code> – индекс искомого элемента;</li>
        <li><code class="highlight">Left</code> – индекс элемента с которого начинается множество;</li>
        <li><code class="highlight">Right</code> - индекс последнего элемента множества;</li>
        <li><code class="highlight">Key</code> – значение искомого элемента;</li>
        <li><code class="highlight">A[]</code> – значение элементов заданного множества.</li>
    </ul>
    &#8226; Пусть во множестве содержится <code class="highlight">1000</code> элементов со значениями от <code class="highlight">1</code> до <code class="highlight">100</code>. Искомым элементом является число <code class="highlight">30</code>, следовательно, поиск выполняется в первой трети множества, в области элемента с индексом, равным <code class="highlight">300</code>. В том случае, если значение этого элемента не равно заданному числу, то учитывая свойство отсортированности заданного множества, алгоритм рассматривает элементы слева или справа.[6] В случае не совпадения, вновь рассматриваемого элемента множества искомому, алгоритм повторяет поиск. На рисунке 6 представлен алгоритм интерполяционного поиска элемента со значением, равным <code class="highlight">77</code>. 
    <img src="<?php echo $folder_name ?>img/8schm.jpg"  alt="Рисунок 6">
    <p style="text-align: center;">Рисунок 6 - Алгоритм интерполяционного поиска</p>
    <br>
    &#8226; В том случае, если значения элементов множества распределены очень неравномерно, то данный алгоритм обладает производительностью <code class="highlight">O(N)</code>, но при относительно равномерном распределении производительность составит <code class="highlight">O(log (log N))</code>.
    <br>
    &#8226; В общем случае, алгоритм интерполяционного поиска является самым быстрым скорость зависит от разброса значений элементов заданного множества. В целом, искомый элемент удается определить за один-два шага, но в некоторых случаях могут понадобиться четыре-пять шагов. 
    <div class="spollers__item">
        <div class="spollers__title spoller closeall">Фрагмент алгоритма Интерполяционного поиска на алгоритмическом языке С++ (развернуть)...</div>
            <div class="spollers__text">
                <pre class="highlight"><code data-language="c" id="">int interpolsearch(int* arr, int size, int key)
{
int left = 0; // левая граница множества
int right = size; // правая граница множества
int mid = 0; //переменная для записи индекса искомого элемента
bool found = false;
while ((left &#60;= right) && found != true)
{
mid = left + ((key - arr[left]) * (right - left)) / (arr[right] - arr[left]); // формула 3 из теории
if (arr[mid] &#60; key) left = mid + 1; /* Если искомое значение элемента множества больше значения элемента множества с индексом mid, то алгоритм начинает новый поиск в правой половине множества; */
else if (arr[mid] &#62; key) right = mid + 1; /* Иначе, если искомое значение элемента множества меньше значения элемента множества с индексом mid, то алгоритм начинает новый поиск в левой половине множества; */
else found = true;
}
if (arr[left] == key)

return left;
}
else if (arr[right] == key)
{
return right;
}
return -1;	
}</code></pre>
            </div>
        </div>
</div>

<h2 id="3">3. Список литературы</h2>
<div class="block__text">
    &#8195;&#8195;1. Стивенс Род. Алгоритмы теория и практическое применение, 2016. –163с. 
    <br>
    &#8195;&#8195;2. Кен Браунси. Структура данных и реализация в С++, 2016. –122с. 
    <br>
    &#8195;&#8195;3.&#8194;Алгоритм Бойера-Мура [Электронный ресурс], 2020. URL: <a href="https://neerc.ifmo.ru/wiki/index.php?title=Алгоритм_Бойера-Мура">https://neerc.ifmo.ru/wiki/index.php?title=Алгоритм_Бойера-Мура</a> (дата обращения 10.03.2020).
    <br>
    &#8195;&#8195;4.&#8194;Алгоритмы поиска данных. Бинарный поиск. [Электронный ресурс], 2020. URL: <a href="https://www.intuit.ru/studies/courses/648/504/lecture/11466м">https://www.intuit.ru/studies/courses/648/504/lecture/11466м</a>  (дата обращения 08.03.2020).
    <br>
    &#8195;&#8195;5. Никлаус Вирт. Алгоритмы и структуры данных, 2017. –114с
    <br>
    &#8195;&#8195;6. Алгоритмы поиска данных. Интерполяционный поиск. [Электронный ресурс], 2020. URL: <a href="http://kvodo.ru/interpoliruyushhiy-poisk.html">http://kvodo.ru/interpoliruyushhiy-poisk.html</a>  (дата обращения 07.03.2020).
</div>
</main><!--end main-->
</div><!--end .row-->
<?php include ($r_base."assets/php_modules/footer.tpt.php"); ?>  
</div><!--end .container-fluid-->
<?php include ($r_base."assets/php_modules/scripts.tpt.php"); ?>
</body>
</html>