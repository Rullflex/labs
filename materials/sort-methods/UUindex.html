<!DOCTYPE html>
<html lang="ru">
<head>
	
	<title>Алгоритмы сортировок данных</title>
	<!-- Meta Data -->
	<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
	<meta name="format-detection" content="telephone=no">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="author" content="Dmitry Gorshkov">
	<meta name="description" content="Обучающие материалы по теме: Алгоритмы сортировок данных, реализованных на C++. Материал подготовлен кафедрой ИТАС ПНИПУ">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
	<!-- <meta name="robots" content="noindex, nofollow" /> -->
	<!-- Links -->
	<link rel="icon" href="../favicon.ico" type="image/x-icon">
    <link rel="shortcut icon" href="../favicon.ico" type="image/x-icon">
	<link rel="stylesheet" href="../css/style.css">
	<link rel="stylesheet" href="../css/custom.css">
	<link rel="stylesheet" href="../css/hdx.css">
	<link rel="stylesheet" href="../css/themes/kimbie-light.css">

	<!-- Head Scripts -->
	<script src="https://kit.fontawesome.com/49e499dad5.js" crossorigin="anonymous"></script>
</head>
<body>
	<div class="wrapper">
		<header>
	<div class="container">
		<div class="header-body">
		</div>
	</div>
</header>
		
		<div class='container-fluid'>
			<div class="row">
			<!-- Aside Desktop -->
			<aside class="col-md aside-desktop">
			
				<header><h1><a href="http://info.rully.ru/sort-methods/" title="http://info.rully.ru/sort-methods/">Алгоритмы сортировок данных</a></h1>
				
					<p>
						<i class="fas fa-caret-left"></i> <a href="http://info.rully.ru/" title="http://info.rully.ru/">На главную</a>
						<br>
						<i class="fas fa-caret-right"></i> <a href="/sort-methods/lab/">Лабораторная работа №17</a>
					</p>
				</header>
				<hr>
				<button aria-controls="nav" aria-expanded="false" class="btn btn-sm collapsed d-md-none" data-target="aside > nav" data-toggle="collapse">
					Меню
				</button>
				<nav class="collapse d-md-block">
					<ol start="1">

						<li><a href="#1">Анализ сложности алгоритмов</a></li>
						<li><a href="#2">Методы сортировки</a></li>
						<li><a href="#3">Сравнительный анализ времени работы алгоритмов</a></li>
						<li><a href="#4">Блок-схемы сортировок</a></li>
						
					</ol>
				</nav>
				<hr>
			</aside>
			<!-- End Aside Desktop-->
			<!-- Aside Device -->
			<aside class="col-md aside-device">
			
				<header><h1><a href="http://info.rully.ru/sort-methods/" title="http://info.rully.ru/sort-methods/">Алгоритмы сортировок данных</a></h1>
				
					<p>
						<i class="fas fa-caret-left"></i> <a href="http://info.rully.ru/" title="http://info.rully.ru/">На главную</a>
						<br>
						<i class="fas fa-caret-right"></i> <a href="/sort-methods/lab/">Лабораторная работа №17</a>
					</p>
				</header>
				<hr>
			</aside>
			<aside class="col-md aside-device" style="position: sticky; top: 0; z-index: 111111; padding-top: 16px; padding-bottom: 16px;">
				<button aria-controls="nav" aria-expanded="false" class="btn btn-sm collapsed d-md-none" data-target="aside > nav" data-toggle="collapse" style="margin-top: 0;">
					Меню
				</button>
				<nav class="collapse d-md-block">
					<ol start="1">
						<li><a href="#1">Анализ сложности алгоритмов</a></li>
						<li><a href="#2">Методы сортировки</a></li>
						<li><a href="#3">Сравнительный анализ времени работы алгоритмов</a></li>
						<li><a href="#4">Блок-схемы сортировок</a></li>
						
					</ol>
				</nav>
			</aside>
			<!-- End Aside Device-->

			<main class="col-md markdown-body">
			<h2 id="1">1. Анализ сложности алгоритмов</h2>
			<div class="block__text text-justify">
				&#8226; Одним из самых фундаментальных инструментов анализа сложности алгоритма с использованием алгебраических терминов, является Нотация <b>О большое</b>.
				<br>
				&#8226; <b>Нотация О большое</b> – это математическая нотация, которая описывает ограничивающее поведение функции, когда аргумент стремится к определенному значению или бесконечности. Он является членом семейства нотаций, изобретенных Полом Бахманом, Эдмундом Ландау и другими, которые в совокупности называются нотациями Бахмана-Ландау или асимптотическими нотациями. [1]
				
			</div>

			<h3>1.1 Сравнение сложности между всеми нотациями</h3>
			<div class="block__text text-justify">
				&#8226; Порядок роста описывает то, как сложность алгоритма растет с увеличением размера входных данных. Чаще всего представляется в виде O-нотации (от нем. «Ordnung» — порядок) : <code class="highlight">O(f(x))</code>, где <code class="highlight">f(x)</code> — формула, выражающая сложность алгоритма. В формуле может присутствовать переменная n, представляющая размер входных данных. Ниже приводится список наиболее часто встречающихся порядков роста, но он ни в коем случае не полный
				<h44>Константный — O(1)</h4>
				&#8226; Порядок роста <code class="highlight">O(1)</code> означает, что вычислительная сложность алгоритма не зависит от размера входных данных. Следует помнить, однако, что единица в формуле не значит, что алгоритм выполняется за одну операцию или требует очень мало времени. Важно то, что это время не зависит от входных данных.
				<pre class="highlight"><code data-language="c" id="">int GetCount(int items[])
{
    return items.Length;
}</code></pre>
				<h4>Линейный — O(n)</h4>
				&#8226; Порядок роста <code class="highlight">O(n)</code> означает, что сложность алгоритма линейно растет с увеличением входного массива. Если линейный алгоритм обрабатывает один элемент пять миллисекунд, то можно ожидать, что тысячу элементов обрабатывается за пять секунд. Такие алгоритмы легко узнать по наличию цикла по каждому элементу входного массива.
				<pre class="highlight"><code data-language="c" id="">long GetSum(int items[])
{
	long sum = 0;
	for (int i = 0; i &#60; items.Length; i++)
	{
		sum += i;
	}

	return sum;
}</code></pre>
				<h4>Логарифмический – O(log n)</h4>
				&#8226; Порядок роста <code class="highlight">O(log n)</code> означает, что время выполнения алгоритма растет логарифмически с увеличением размера входного массива. (в анализе алгоритмов по умолчанию используется логарифм по основанию 2). Большинство алгоритмов, работающих по принципу «деления пополам», имеют логарифмическую сложность. Метод <code class="highlight">Contains</code> бинарного дерева поиска (binary search tree) также имеет порядок роста <code class="highlight">O(log n)</code>.
				<h4>Линеарифметический — O(n·log n)</h4>
				&#8226; Линеарифметический (или линейно-логарифмический) алгоритм имеет порядок роста <code class="highlight">O(n·log n)</code>. Некоторые алгоритмы типа «разделяй и властвуй» попадают в эту категорию. Далее будут рассмотрены примеры данного алгоритма — сортировка слиянием и быстрая сортировка.
				<h4>Квадратичный — O(n<sup>2</sup>)</h4>
				&#8226; Время работы алгоритма с порядком роста <code class="highlight">O(n<sup>2</sup>)</code> зависит от квадрата размера входного массива. Несмотря на то, что такой ситуации иногда не избежать, квадратичная сложность — повод пересмотреть используемые алгоритмы или структуры данных. Проблема в том, что они плохо масштабируются. Например, если массив из тысячи элементов потребует <code class="highlight">1 000 000</code> операций, массив из миллиона элементов потребует <code class="highlight">1 000 000 000 000</code> операций. Если одна операция требует миллисекунду для выполнения, квадратичный алгоритм будет обрабатывать миллион элементов <code class="highlight">32</code> года.
			</div>

			<h3>1.2 Наилучший, средний и наихудший случаи</h3>
			<div class="block__text text-justify">
				&#8226; Что имеется в виду, когда говорится, что порядок роста сложности алгоритма — <code class="highlight">O(n)</code>? Это усредненный случай? Или наихудший случай? А может быть, наилучший случай? Обычно имеется в виду наихудший случай, за исключением тех случаев, когда наихудший и средний сильно отличаются. К примеру, алгоритмы, которые в среднем имеют порядок роста <code class="highlight">O(1)</code>, но периодически могут становиться <code class="highlight">O(n)</code> (например, <code class="highlight">ArrayList.add</code>). В этом случае указывается, что алгоритм работает в среднем за константное время, когда сложность возрастает. Самое важное здесь то, что <code class="highlight">O(n)</code> означает, что алгоритм потребует <b>не более</b> <code class="highlight">n</code> шагов.
			</div>

			<h3>1.3 Сложность алгоритмов</h3>
			<div class="block__text text-justify">
				&#8226; При измерении сложности алгоритмов и структур данных учитывается: количество операций, требуемых для завершения работы (вычислительная сложность), и объем ресурсов, в частности, памяти, который необходим алгоритму (пространственная сложность).
				<br>
				&#8226; Алгоритм, который выполняется в десять раз быстрее, но использует в десять раз больше памяти, может вполне подходить для серверной машины с большим объемом памяти. Но на встроенных системах, где количество памяти ограничено, такой алгоритм использовать нельзя. [2]
			</div>

			<h2 id="2">2. Методы сортировки</h2>
			<div class="block__text text-justify">
				&#8226; Массивы часто используются для хранения и быстрого поиска данных в них. Но чтобы затрачивать на поиск наименьшее время, необходимо, чтобы массив был отсортирован.
			</div>

			<h3>2.1 Сортировка слиянием</h3>
			<table>
				<tbody>
				<tr>
				<td><b>Сложность</b></td>
				<td>Наилучший случай</td>
				<td>В среднем</td>
				<td>Наихудший случай</td>
				</tr>
				<tr>
				<td>Время</td>
				<td>O(n·log&thinsp;n)</td>
				<td>O(n·log&thinsp;n)</td>
				<td>O(n·log&thinsp;n)</td>
				</tr>
				<tr>
				<td>Память</td>
				<td>O(n)</td>
				<td>O(n)</td>
				<td>O(n)</td>
				</tr>
				</tbody>
			</table>
			<div class="block__text text-justify">
				&#8226; Линейные алгоритмы используют мало дополнительной памяти, но имеют квадратичную сложность. На примере сортировки слиянием, используется алгоритм типа «разделяй и властвуй» (<code class="highlight">divide and conquer</code>).
				<br>
				&#8226; Алгоритмы этого типа работают, разделяя крупную задачу на более мелкие, решаемые проще. К примеру, поиск в телефонной книге — один из примеров такого алгоритма.
				<br>
				&#8226; Если необходимо найти человека по фамилии <code class="highlight">Петров</code>, не стоит искать, начиная с буквы <code class="highlight">А</code> и переворачивая по одной странице. Скорее всего, стоит открыть книгу где-то посередине. Если выпадает буква <code class="highlight">Т</code>, стоит перелистнуть на несколько страниц назад, до буквы <code class="highlight">О</code>. Тогда следуя алгоритму необходимо идти вперед. Таким образом, перелистывая туда и обратно все меньшее количество страниц, в конце концов, найдется нужный контакт.
				<br>
				&#8226; Предположим, что в телефонной книге <code class="highlight">1000</code> страниц. Если открывать ее на середине, отбрасывается <code class="highlight">500</code> страниц, в которых нет искомого человека. Если не попали на нужную страницу, выбирается правая или левая сторона и снова оставляется половина доступных вариантов. Теперь необходимо просмотреть <code class="highlight">250</code> страниц. Таким образом, задача делится пополам снова и снова, до тех пор, пока не найден человек, в этом случае телефон искомого человека в книге, найден всего за <code class="highlight">10</code> просмотров. Это составляет 1% от всего количества страниц, которые пришлось бы просмотреть при линейном поиске.
				<br>
				&#8226; При сортировке слиянием, массив разделяется пополам до тех пор, пока каждый участок не станет длиной в один элемент. Затем эти участки возвращаются на место (сливаются) в правильном порядке. Пример алгоритма сортировки слиянием, представлен на рисунках 1 и 2.
				<img src="img/1arr.jpg" alt="Рисунок 1">
				<p style="text-align: center;">Рисунок 1 - Алгоритм сортировки слиянием</p>
				&#8226; На рисунке 1, следует отметить, что исходный массив разделяется на 2 части, до тех пор, пока не будет получен массив, состоящий из одного символа.
				<img src="img/1.png" alt="Рисунок 2">
				<p style="text-align: center;">Рисунок 2 - Алгоритм сортировки слиянием</p>
				&#8226; В итоге работы алгоритма, исходный массив данных преобразуется в отсортированный, путем сравнивания разделенных элементов между собой, как показано на рисунке 2.
				<br>
				&#8226; Для работы алгоритма следует реализовать следующие операции: 
				<br>
				&#8195;&#8195;&#8212; Операцию для рекурсивного разделения массива на группы (метод Sort);
				<br>
				&#8195;&#8195;&#8212; Слияние в правильном порядке (метод Merge);
				<br>
				&#8226; Стоит отметить, что в отличие от линейных алгоритмов сортировки, сортировка слиянием будет делить и склеивать массив вне зависимости от того, был он отсортирован изначально или нет. Поэтому, несмотря на то, что в худшем случае алгоритм отработает быстрее, чем линейный, в лучшем случае, производительность алгоритма будет ниже, чем у линейного. Поэтому сортировка слиянием — не самое лучшее решение, когда необходимо отсортировать частично упорядоченный массив. 
				<br>
				&#8226; Недостатки метода заключаются в том, что требуется дополнительная память по объему равной объему сортируемого файла. Поэтому для больших файлов проблематично организовать сортировку слиянием в оперативной памяти. 
				<br>
				&#8226; В случаях, когда гарантированное время сортировки важно и размещение в оперативной памяти, возможно, следует предпочесть метод сортировки слиянием. 
			</div>

			<h3>2.2 Быстрая сортировка</h3>
			<table>
				<tbody>
					<tr>
						<td><b>Сложность</b></td>
						<td>Наилучший случай</td>
						<td>В среднем</td>
						<td>Наихудший случай</td>
					</tr>
					<tr>
						<td>Время</td>
						<td>O(n·log&thinsp;n)</td>
						<td>O(n·log&thinsp;n)</td>
						<td>O(n<sup>2</sup>)</td>
					</tr>
					<tr>
						<td>Память</td>
						<td>O(n)</td>
						<td>O(n)</td>
						<td>O(n)</td>
					</tr>
				</tbody>
			</table>
			<div class="block__text text-justify">
				&#8226; Быстрая сортировка — это еще один алгоритм типа «разделяй и властвуй», который работает рекурсивно, повторяя следующие шаги:
				<br>
				&#8195;&#8195;&#8212; Выбрать ключевой индекс и разделить по нему массив на две части. Это можно делать разными способами.
				<br>
				&#8195;&#8195;&#8212; Переместить все элементы больше ключевого в правую часть массива, а все элементы меньше ключевого — в левую. Таким образом, ключевой элемент находится в правильной позиции — ключевой элемент больше любого элемента слева и меньше любого элемента справа; 
				<br>
				&#8195;&#8195;&#8212; Повторяются первые два шага, пока массив не будет полностью отсортирован;
				<br>
				&#8226; В качестве примера, рассмотрен следующий массив, на рисунке 3: 
				<img src="img/data_structures_052.webp" alt="Рисунок 3">
				<p style="text-align: center;">Рисунок 3 – Алгоритм быстрой сортировки</p>
				В начале, случайным образом выбирается ключевой элемент, на рисунке 4, случайным числом является элемент с индексом 4 (нумерация индексов, начинается с 0).
				<pre class="highlight"><code data-language="c">int pivotIndex = _pivotRng.Next(left, right);</code></pre>
				<img src="img/data_structures_053.webp" alt="Рисунок 4">
				<p style="text-align: center;">Рисунок 4 - Алгоритм быстрой сортировки</p>
				Теперь, из вычисленного ключевого индекса (4), берется значение, находящееся по этому индексу (6), и значение переносится в массиве так, чтобы все числа больше или равные ключевому были в правой части, а все числа меньше ключевого — в левой. Следует обратить внимание, что в процессе переноса значений индекс ключевого элемента может измениться. Перемещение значений осуществляется методом <code class="highlight">partition</code>. 

				<img src="img/data_structures_054.jpg" alt="Рисунок 5">
				<p style="text-align: center;">Рисунок 5 - Алгоритм быстрой сортировки</p>
				На рисунке 5, видно, что значение 6 находится на правильной позиции. Теперь повторяется этот процесс для правой и левой частей массива. Таким образом рекурсивно вызывается метод <code class="highlight">quicksort</code> на каждой из частей. Ключевым элементом в левой части становится элемент с индексом 1, как показано на рисунке 6. При перемещении значений индекс будет изменен. Главное — помнить, что важно именно ключевое значение, а не его индекс.
				<img src="img/data_structures_055.webp" alt="Рисунок 6">
				<p style="text-align: center;">Рисунок 6 - Алгоритм быстрой сортировки</p>
				Применив быструю сортировку (рисунок 7), получаем следующий массив данных: 
				<img src="img/data_structures_056.webp" alt="Рисунок 7">
				<p style="text-align: center;">Рисунок 7 - Алгоритм быстрой сортировки</p>
				И еще раз:
				<img src="img/data_structures_057.jpg" alt="Рисунок 8">
				<p style="text-align: center;">Рисунок 8 - Алгоритм быстрой сортировки</p>
				Таким образом, осталось одно неотсортированное значение, а, поскольку, все остальное уже отсортировано, алгоритм завершает работу. [3]
				<br>
			</div><!-- End .block__text -->

			<h3>2.3 Сортировка подсчетом</h3>
			<div class="block__text text-justify">
				&#8226; Подобный метод удобно использовать в том случае, если сортировать приходится целые числа, лежащие в относительно небольшом диапазоне. Например, необходимо упорядочить 1 млн целых чисел от 0 до 1000. Основная идея заключается в том, чтобы установить количество элементов массива с определенным значением, а затем скопировать это значение по порядку нужное количество раз обратно в массив.
				<br>
				<a href="https://docs.google.com/presentation/d/18ZmVyGaXUrMVwtm0iRmTnPIAKcwFPtOy/present?ueb=true&slide=id.p1" title="docs.google.com/" target="_blank">Визуализация сортировки (презентация)</a> 
				<br>
				&#8226; На практике для тестового массива с 1 млн элементов и диапазоном значений от 0 до 1000, быстрая сортировка заняла 4,29 с, а сортировка подсчетом — всего 0,03 с. Следует отметить, что для быстрой сортировки выбранный пример оказался не самым лучшим, поскольку среди значений было множество дубликатов (приблизительно 1000), а данный алгоритм справляется с ними плохо. Пирамидальная сортировка аналогичного массива длилась около 1,02 с., что эффективнее быстрой сортировки, но все равно значительно уступила сортировке подсчетом. 
			</div>

			<h3>2.4 Блочная сортировка</h3>
			<div class="block__text text-justify">
				&#8226; Алгоритм блочной (корзинной) сортировки разделяет элементы на блоки, а затем сортирует с помощью рекурсивного вызова блочной сортировки, либо другого алгоритма и присоединяет, содержимое блоков к исходному массиву. 

			</div>

			<h2 id="3">3. Сравнительный анализ времени работы алгоритмов</h2>
			&#8226; Алгоритмы сортировки, описанные в текущей главе, используют разные методы и обладают различными характеристиками:
			<br>
			<table>
				<tbody>
					<tr>
						<td><b>Сортировка</b></td>
						<td><b>Время работы</b></td>
						<td><b>Метод</b></td>
						<td><b>Область использования</b></td>
					</tr>
					<tr>
						<td>Вставкой</td>
						<td>O(n<sup>2</sup>)</td>
						<td>Вставка</td>
						<td>Очень малые массивы</td>
					</tr>
					<tr>
						<td>Выбором</td>
						<td>O(n<sup>2</sup>)</td>
						<td>Выбор</td>
						<td>Очень малые массивы</td>
					</tr>
					<tr>
						<td>Пузырьковая</td>
						<td>O(n<sup>2</sup>)</td>
						<td>Двусторонние прохождения,<br> ограничения рассматриваемых пределов</td>
						<td>Очень малые и частично<br> сортированные массивы</td>
					</tr>
					<tr>
						<td>Пирамидальная</td>
						<td>O(n·log&thinsp;n)</td>
						<td>Кучи, хранение полных<br> деревьев в массиве</td>
						<td>Крупные массивы с неизвестным<br> распределением</td>
					</tr>
					<tr>
						<td>Быстрая</td>
						<td>O(n·log&thinsp;n)<br>O(n<sup>2</sup>)-худший</td>
						<td>«Разделяй и властвуй», перемещение<br> элементов в позицию, рандомизация<br> во избежание худшего случая</td>
						<td>Крупные массивы без большого количества<br> дубликатов, параллельная сортировка</td>
					</tr>
					<tr>
						<td>Слиянием</td>
						<td>O(n·log&thinsp;n)</td>
						<td>«Разделяй и властвуй», объединение,<br> внешняя сортировка</td>
						<td>Крупные массивы с неиз- вестным<br> распределением, большие объемы данных,<br> параллельная сортировка</td>
					</tr>
					<tr>
						<td>Подсчетом</td>
						<td>O(n + m)</td>
						<td>Счет</td>
						<td>Крупные массивы с достаточно<br> единообразным распределением значений</td>
					</tr>
				</tbody>
			</table>

			<h2  id="4">4. Блок-схемы сортировок</h2>
			<div class="block__gallery gallery-block gallery">
				<a href="img/block_schemes/block_scheme01.jpg" class="gallery-block__item">
					<img src="img/block_schemes/block_scheme01.jpg" alt=""></a>
				<a href="img/block_schemes/block_scheme02.jpg" class="gallery-block__item">
					<img src="img/block_schemes/block_scheme02.jpg" alt=""></a>
				<a href="img/block_schemes/block_scheme03.jpg" class="gallery-block__item">
					<img src="img/block_schemes/block_scheme03.jpg" alt=""></a>
				<a href="img/block_schemes/block_scheme04.jpg" class="gallery-block__item">
					<img src="img/block_schemes/block_scheme04.jpg" alt=""></a>
				<a href="img/block_schemes/block_scheme05.jpg" class="gallery-block__item">
					<img src="img/block_schemes/block_scheme05.jpg" alt=""></a>
				<a href="img/block_schemes/block_scheme06.jpg" class="gallery-block__item">
					<img src="img/block_schemes/block_scheme06.jpg" alt=""></a>
				<a href="img/block_schemes/block_scheme07.jpg" class="gallery-block__item">
					<img src="img/block_schemes/block_scheme07.jpg" alt=""></a>
				<a href="img/block_schemes/block_scheme08.jpg" class="gallery-block__item">
					<img src="img/block_schemes/block_scheme08.jpg" alt=""></a>
				<a href="img/block_schemes/block_scheme09.jpg" class="gallery-block__item">
					<img src="img/block_schemes/block_scheme09.jpg" alt=""></a>
				<a href="img/block_schemes/block_scheme10.jpg" class="gallery-block__item">
					<img src="img/block_schemes/block_scheme10.jpg" alt=""></a>
				<a href="img/block_schemes/block_scheme11.jpg" class="gallery-block__item">
					<img src="img/block_schemes/block_scheme11.jpg" alt=""></a>
				<a href="img/block_schemes/block_scheme12.jpg" class="gallery-block__item">
					<img src="img/block_schemes/block_scheme12.jpg" alt=""></a>
				<a href="img/block_schemes/block_scheme13.jpg" class="gallery-block__item">
					<img src="img/block_schemes/block_scheme13.jpg" alt=""></a>
				<a href="img/block_schemes/block_scheme14.jpg" class="gallery-block__item">
					<img src="img/block_schemes/block_scheme14.jpg" alt=""></a>
				<a href="img/block_schemes/block_scheme15.jpg" class="gallery-block__item">
					<img src="img/block_schemes/block_scheme15.jpg" alt=""></a>
			</div>

			
		</main>
		</div><!-- End .row-->
		</div><!-- End .container-->

		<footer>
	<div class='container'>
		<div class="footer-body">
			
		</div>
	</div>
</footer>

	</div> <!-- End .wrapper -->

	<!-- Scripts -->
	

<div class="popup popup-video">
	<div class="popup-table table">
		<div class="cell">
			<div class="popup-close"></div>
			<div class="popup-video__value"></div>
		</div>
	</div>
</div>





	<script src="https://code.jquery.com/jquery-3.3.1.min.js"></script>
<script src="https://code.jquery.com/ui/1.12.1/jquery-ui.min.js"></script>
<script src="../js/popper.min.js"></script>
<script src="../js/bootstrap.min.js"></script>
<script src="../js/rainbow-custom.min.js"></script>
<script src="../js/clipboard.min.js"></script>
<script src="../js/vendors.js"></script>
<script src="../js/main.js"></script>
<script src="../js/custom.js" ></script>


</body>
</html>